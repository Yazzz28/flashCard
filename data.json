{
  "frontend": [
    {
      "question": "Qu'est-ce qu'une SPA ?",
      "answer": "Une SPA (Single Page Application) est une application web qui charge une seule page HTML et met à jour dynamiquement le contenu en fonction des interactions de l'utilisateur, sans recharger la page entière. Les SPAs utilisent JavaScript pour manipuler le DOM et communiquent avec le serveur via des APIs pour récupérer ou envoyer des données. Avantages : performance améliorée, expérience utilisateur fluide. Inconvénients : SEO plus complexe, temps de chargement initial plus long."
    },
    {
      "question": "Qu'est-ce qu'Angular ?",
      "answer": "Angular est un framework JavaScript open-source développé par Google pour créer des applications web dynamiques et des SPAs. Il utilise TypeScript par défaut, suit une architecture basée sur des composants, et propose des fonctionnalités comme le data binding bidirectionnel, l'injection de dépendances, le routing, et les directives. Angular facilite le développement d'applications complexes avec une structure organisée et maintenable."
    },
    {
      "question": "Quels sont les avantages d'un framework orienté composant comme Angular ?",
      "answer": "Les avantages incluent : la réutilisabilité des composants dans différentes parties de l'application, une meilleure organisation du code en modules logiques, la facilité de maintenance et de test des composants isolés, l'encapsulation qui évite les conflits entre composants, la possibilité de développer en équipe avec des responsabilités claires par composant, et la scalabilité pour les grandes applications."
    },
    {
      "question": "Quels sont les prérequis pour installer et exécuter un projet Angular ?",
      "answer": "Les prérequis sont : Node.js (version LTS recommandée) avec npm ou yarn comme gestionnaire de paquets, Angular CLI installé globalement (npm install -g @angular/cli), un éditeur de code (VS Code recommandé), et optionnellement Git pour le versioning. Pour créer un projet : ng new mon-projet, puis ng serve pour le lancer en mode développement."
    },
    {
      "question": "Comment gères-tu un événement utilisateur dans Angular ?",
      "answer": "Dans Angular, on gère les événements avec l'event binding en utilisant des parenthèses : (click)='maMethode()', (submit)='onSubmit()', (change)='onChange($event)'. On peut accéder à l'objet event avec $event. Dans le composant TypeScript, on définit les méthodes correspondantes. Exemple : <button (click)='onClick()'>Click me</button> et dans le composant : onClick() { console.log('Bouton cliqué'); }"
    },
    {
      "question": "Comment récupères-tu des données d'une API dans une interface Angular ?",
      "answer": "On utilise le service HttpClient d'Angular : 1) Importer HttpClientModule dans app.module.ts, 2) Injecter HttpClient dans le service ou composant, 3) Utiliser les méthodes HTTP (get, post, put, delete) qui retournent des Observables, 4) S'abonner aux Observables avec subscribe() ou utiliser async pipe dans le template. Exemple : this.http.get<User[]>('/api/users').subscribe(users => this.users = users);"
    },
    {
      "question": "Comment sécuriser les pages en Angular selon le rôle de l'utilisateur ?",
      "answer": "On utilise les Guards d'Angular : 1) CanActivate pour protéger l'accès aux routes, 2) Créer un AuthGuard qui vérifie l'authentification et les rôles, 3) Implémenter la méthode canActivate() qui retourne true/false, 4) Ajouter le guard dans les routes : { path: 'admin', component: AdminComponent, canActivate: [AuthGuard] }, 5) Vérifier les tokens JWT et rôles côté serveur également."
    },
    {
      "question": "Comment rends-tu une interface responsive ?",
      "answer": "Pour rendre une interface responsive : 1) Utiliser CSS Grid et Flexbox pour des layouts adaptatifs, 2) Définir des media queries pour différentes tailles d'écran, 3) Utiliser des unités relatives (%, em, rem, vw, vh), 4) Adopter l'approche mobile-first, 5) Utiliser des frameworks CSS comme Bootstrap ou Tailwind, 6) Tester sur différents appareils et tailles d'écran, 7) Optimiser les images avec srcset et picture."
    },
    {
      "question": "Pourquoi est-il important d'adapter une interface à différents types de supports ?",
      "answer": "C'est important car : 1) Plus de 50% du trafic web vient du mobile, 2) Google privilégie les sites mobile-friendly dans son référencement, 3) L'expérience utilisateur varie selon l'appareil utilisé, 4) Cela améliore l'accessibilité pour tous les utilisateurs, 5) Cela augmente le taux de conversion et réduit le taux de rebond, 6) C'est une exigence professionnelle moderne."
    },
    {
      "question": "Comment t'assures-tu que ton interface respecte la maquette du dossier de conception ?",
      "answer": "Pour respecter la maquette : 1) Comparaison pixel-perfect avec des outils de superposition, 2) Utilisation d'un design system cohérent, 3) Respect des spacing, couleurs et typographies définies, 4) Tests sur différents navigateurs et appareils, 5) Validation avec l'équipe design, 6) Utilisation d'outils comme Figma inspect ou Zeplin, 7) Documentation des écarts justifiés, 8) Tests d'intégration réguliers pendant le développement."
    },
    {
      "question": "Pourquoi et comment tester une interface utilisateur ?",
      "answer": "Tests UI essentiels pour : 1) Validation fonctionnelle des interactions, 2) Détection de régressions visuelles, 3) Vérification de l'accessibilité, 4) Performance et responsive design. Comment : Tests automatisés (Selenium, Cypress, Playwright), tests manuels, tests d'utilisabilité, tests de compatibilité navigateurs, tests de performance (Lighthouse), validation W3C, tests d'accessibilité (axe, Wave). Combine approches pour couverture complète."
    },
    {
      "question": "Quels mécanismes peux-tu mettre en place pour sécuriser une interface ?",
      "answer": "Sécurisation interface : 1) Validation côté client ET serveur, 2) Échappement des données utilisateur, 3) CSP (Content Security Policy) headers, 4) HTTPS obligatoire, 5) Protection CSRF avec tokens, 6) Sanitization des entrées, 7) Rate limiting, 8) Authentification et autorisation, 9) Audit sécurité régulier, 10) Mise à jour des dépendances, 11) CORS configuré correctement, 12) Headers sécurisés (X-Frame-Options, X-XSS-Protection)."
    },
    {
      "question": "Comment fonctionne le DOM et quelle est son importance dans les interfaces web ?",
      "answer": "Le DOM (Document Object Model) est une représentation en arbre des éléments HTML d'une page web. Chaque balise devient un nœud que JavaScript peut manipuler dynamiquement. Son importance : 1) Permet l'interactivité via JavaScript, 2) Structure hiérarchique des éléments, 3) Interface entre HTML/CSS et JavaScript, 4) Permet la manipulation en temps réel du contenu, 5) Base pour les frameworks modernes, 6) Gestion des événements utilisateur."
    },
    {
      "question": "Quelles sont les principales vulnérabilités web (XSS, CSRF) et comment s'en prémunir ?",
      "answer": "XSS (Cross-Site Scripting) : injection de scripts malveillants. Prévention : validation et échappement des données, CSP headers. CSRF (Cross-Site Request Forgery) : exécution d'actions non autorisées. Prévention : tokens CSRF, vérification de l'origine, SameSite cookies. Autres vulnérabilités : injection SQL (requêtes préparées), clickjacking (X-Frame-Options), HTTPS obligatoire, validation côté serveur."
    },
    {
      "question": "Comment se protéger contre les injections SQL, XSS et CSRF ?",
      "answer": "Protection multicouche : SQL Injection : requêtes préparées, ORM, validation stricte, principe moindre privilège DB. XSS : échappement HTML, CSP, validation entrées, sanitization. CSRF : tokens synchronisés, SameSite cookies, vérification Referer/Origin. Général : validation côté serveur obligatoire, encodage approprié, framework sécurisé, tests sécurité, monitoring, formation équipe. Never trust user input !"
    },
    {
      "question": "Pourquoi doit-on valider les données côté frontend et backend ?",
      "answer": "Double validation nécessaire : Frontend : UX améliorée, feedback immédiat, réduction requêtes serveur, guide utilisateur. Backend : sécurité réelle (frontend contournable), intégrité données, conformité business rules, protection API. Frontend = confort utilisateur, Backend = sécurité obligatoire. Les validations frontend peuvent être désactivées/modifiées, donc backend reste la barrière de sécurité principale. Principe : never trust client-side data."
    },
    {
      "question": "Quelles sont les bonnes pratiques UX pour améliorer l'ergonomie d'une interface web ?",
      "answer": "Bonnes pratiques UX : 1) Design intuitif et prévisible, 2) Navigation claire et cohérente, 3) Feedback visuel immédiat, 4) Chargement rapide (<3s), 5) Mobile-first design, 6) Accessibilité universelle, 7) Contenu scannable, 8) CTAs clairs, 9) Formulaires simples, 10) Tests utilisateurs réguliers, 11) Hiérarchie visuelle claire, 12) Erreurs explicites et solutions, 13) Recherche efficace, 14) Personnalisation adaptée."
    },
    {
      "question": "Quels facteurs influencent le référencement SEO d'une interface web ?",
      "answer": "Facteurs SEO : 1) Performance (Core Web Vitals), 2) Mobile-friendly responsive, 3) Structure HTML sémantique, 4) Balises meta optimisées, 5) Contenu de qualité et unique, 6) URL structure claire, 7) Images optimisées avec alt, 8) HTTPS obligatoire, 9) Schema markup, 10) Sitemap XML, 11) Linking interne/externe, 12) Temps de chargement, 13) Accessibilité, 14) Contenu frais régulier, 15) Social signals."
    },
    {
      "question": "Quelles règles d'accessibilité dois-tu respecter lors du développement d'une interface ?",
      "answer": "Règles d'accessibilité WCAG 2.1 : 1) Perceptible : alt text images, contrastes 4.5:1, sous-titres vidéos, 2) Utilisable : navigation clavier, pas de clignotements, temps suffisant, 3) Compréhensible : langage simple, navigation prévisible, aide erreurs, 4) Robuste : HTML valide, compatible assistive technologies. Tests : lecteurs d'écran, validation automatique, audit manuel. Bénéficie à tous les utilisateurs."
    },
    {
      "question": "Comment améliorer l'accessibilité d'une interface ?",
      "answer": "Amélioration accessibilité : 1) HTML sémantique correct, 2) Alternative text pour images, 3) Contrastes suffisants, 4) Navigation clavier fluide, 5) Labels explicites formulaires, 6) ARIA labels appropriés, 7) Focus visible, 8) Tailles cliquables ≥44px, 9) Tests lecteurs d'écran, 10) Vidéos sous-titrées, 11) Structure hiérarchique headings, 12) Messages d'erreur clairs, 13) Temps de session adaptés, 14) Documentation utilisateur."
    },
    {
      "question": "Qu'est-ce que le RGAA et pourquoi est-il important ?",
      "answer": "RGAA (Référentiel Général d'Amélioration de l'Accessibilité) : standard français d'accessibilité numérique basé sur WCAG. Obligatoire pour services publics, recommandé pour privé. Importance : 1) Conformité légale, 2) Inclusion universelle, 3) Amélioration UX globale, 4) SEO renforcé, 5) Image de marque, 6) Marché élargi (12M personnes handicapées France). Certification possible, audits réguliers nécessaires."
    }
  ],
  "backend": [
    {
      "question": "Quels sont les principes SOLID en programmation orientée objet ?",
      "answer": "SOLID est un acronyme de 5 principes : S - Single Responsibility Principle : une classe ne doit avoir qu'une seule responsabilité. O - Open/Closed Principle : ouvert à l'extension, fermé à la modification. L - Liskov Substitution Principle : les objets dérivés doivent pouvoir remplacer leurs objets de base. I - Interface Segregation Principle : préférer plusieurs interfaces spécifiques à une interface générale. D - Dependency Inversion Principle : dépendre d'abstractions, pas de concretions."
    },
    {
      "question": "Quels sont les quatre piliers de la Programmation Orientée Objet (POO) ?",
      "answer": "Les 4 piliers sont : 1) Encapsulation : regrouper données et méthodes dans une classe, contrôler l'accès via les modificateurs (private, protected, public). 2) Héritage : créer de nouvelles classes basées sur des classes existantes, réutiliser et étendre le code. 3) Polymorphisme : capacité d'un objet à prendre plusieurs formes, méthodes ayant le même nom mais comportements différents. 4) Abstraction : masquer la complexité d'implémentation, exposer seulement l'interface nécessaire."
    },
    {
      "question": "Comment fonctionne le polymorphisme en Java ?",
      "answer": "Le polymorphisme en Java permet qu'un même nom de méthode ait différents comportements selon le type d'objet. Il existe deux types : 1) Polymorphisme de compilation (surcharge) : plusieurs méthodes avec le même nom mais paramètres différents. 2) Polymorphisme d'exécution (redéfinition) : une méthode de classe parent redéfinie dans la classe enfant. Java utilise la résolution dynamique des méthodes (late binding) pour déterminer quelle méthode appeler à l'exécution."
    },
    {
      "question": "Pourquoi utilise-t-on des interfaces en POO ?",
      "answer": "Les interfaces servent à : 1) Définir un contrat que les classes doivent respecter, 2) Permettre l'héritage multiple en Java, 3) Faciliter les tests avec des mocks, 4) Découpler le code et améliorer la flexibilité, 5) Respecter le principe d'inversion de dépendance, 6) Permettre le polymorphisme, 7) Standardiser les comportements entre différentes implémentations, 8) Faciliter la maintenance et l'évolutivité du code."
    },
    {
      "question": "Dans quel cas utiliser une classe abstraite plutôt qu'une interface ?",
      "answer": "Utiliser une classe abstraite quand : 1) Partage de code commun entre classes dérivées, 2) Constructeurs avec logique d'initialisation, 3) Variables d'instance partagées, 4) Méthodes avec implémentation par défaut, 5) Contrôle d'accès varié (protected, private), 6) Évolution future sans casser les implémentations. Interface quand : contrat pur, héritage multiple nécessaire, pas de logique partagée. Règle : classe abstraite = relation 'IS-A' forte, interface = capacité 'CAN-DO'."
    },
    {
      "question": "Pourquoi dit-on que l'héritage favorise la réutilisation du code ?",
      "answer": "L'héritage favorise la réutilisation car : 1) Évite la duplication en héritant des méthodes/attributs de la classe parent, 2) Permet l'extension de fonctionnalités existantes, 3) Factorisation du code commun dans la classe de base, 4) Maintenance centralisée des fonctionnalités communes, 5) Respect du principe DRY (Don't Repeat Yourself), 6) Hiérarchie logique des concepts métier. Attention : privilégier composition over inheritance pour éviter couplage fort."
    },
    {
      "question": "Comment empêcher une classe d'être héritée en Java ?",
      "answer": "En Java, utiliser le mot-clé 'final' devant la déclaration de classe : 'public final class MaClasse'. Exemples : String, Integer, Boolean sont des classes final. Pourquoi : 1) Sécurité et intégrité du design, 2) Performance (pas de virtual method calls), 3) Immutabilité garantie, 4) API stable et prévisible. Alternative : constructeur privé avec factory methods pour contrôler l'instanciation sans empêcher l'héritage."
    },
    {
      "question": "Comment garantit-on l'encapsulation des données en Java ?",
      "answer": "Encapsulation en Java : 1) Attributs privés (private), 2) Getters/setters publics pour accès contrôlé, 3) Validation dans les setters, 4) Retour de copies défensives pour objets mutables, 5) Classes internes privées, 6) Package-private quand approprié. Exemple : private String nom; public String getNom() { return nom; } public void setNom(String nom) { if(nom != null) this.nom = nom; }. Protège l'intégrité des données et cache l'implémentation."
    },
    {
      "question": "Une classe peut-elle implémenter plusieurs interfaces en Java ?",
      "answer": "Oui, une classe Java peut implémenter plusieurs interfaces : 'class MaClasse implements Interface1, Interface2, Interface3'. Avantages : 1) Héritage multiple de comportements, 2) Flexibilité architectural, 3) Respect du contrat de plusieurs APIs, 4) Polymorphisme multiple. Attention aux : conflits de méthodes par défaut (résolution explicite requise), complexité accrue. Exemple : class Voiture implements Vehicule, Assurable, Trackable."
    },
    {
      "question": "Pourquoi et comment appliquer le principe de l'encapsulation ?",
      "answer": "Encapsulation : principes et mise en œuvre. Pourquoi : 1) Protection des données internes, 2) Contrôle d'accès et validation, 3) Facilite maintenance et évolution, 4) Réduit couplage, 5) Améliore testabilité. Comment : attributs privés, méthodes publiques d'accès, validation dans setters, documentation des contrats, tests unitaires de l'API publique. Design by contract : préconditions, postconditions, invariants. Résultat : code plus robuste et maintenable."
    },
    {
      "question": "Comment sécuriser une API REST ?",
      "answer": "Pour sécuriser une API REST : 1) Authentification (JWT, OAuth2), 2) Autorisation basée sur les rôles (RBAC), 3) Validation stricte des entrées, 4) Rate limiting pour éviter les attaques DoS, 5) HTTPS obligatoire, 6) CORS configuré correctement, 7) Logs et monitoring des accès, 8) Versionning de l'API, 9) Gestion des erreurs sans exposer d'informations sensibles, 10) Tests de sécurité réguliers."
    },
    {
      "question": "Pourquoi et comment valider les entrées utilisateur dans une API ?",
      "answer": "Validation API critique pour : sécurité (injection, XSS), intégrité données, stabilité système, UX cohérente. Comment : 1) Validation syntaxique (format, type, longueur), 2) Validation sémantique (business rules), 3) Sanitization des entrées, 4) Whitelist validation, 5) Frameworks de validation (Bean Validation JSR-303), 6) Validation en couches (DTO, service, persistence), 7) Messages d'erreur informatifs mais non révélateurs, 8) Logging des tentatives malveillantes."
    },
    {
      "question": "Pourquoi utiliser un format JSON pour les réponses d'une API REST ?",
      "answer": "JSON privilégié pour APIs REST car : 1) Format léger et compact, 2) Support natif JavaScript, 3) Lisible humainement, 4) Largement supporté tous langages, 5) Structure flexible (objets, arrays), 6) Parsing rapide, 7) Standard web moderne, 8) Moins verbeux que XML, 9) Facilite intégration frontend, 10) Bon support tooling (validation, transformation). Alternative : XML pour enterprise, Protocol Buffers pour performance extrême."
    },
    {
      "question": "Comment sécuriser un composant métier dans une application web ?",
      "answer": "Sécurisation composant métier : 1) Validation des entrées systématique, 2) Autorisation granulaire par méthode, 3) Encapsulation des règles business, 4) Audit trail des opérations, 5) Gestion des exceptions sécurisée, 6) Principe de moindre privilège, 7) Tests de sécurité dédiés, 8) Chiffrement des données sensibles, 9) Session management approprié, 10) Logs sécurisés sans données sensibles, 11) Rate limiting par utilisateur/fonction."
    },
    {
      "question": "Quelles sont les principales failles de sécurité en développement web ?",
      "answer": "OWASP Top 10 : 1) Broken Access Control, 2) Cryptographic Failures, 3) Injection (SQL, NoSQL, LDAP), 4) Insecure Design, 5) Security Misconfiguration, 6) Vulnerable Components, 7) Authentication Failures, 8) Software/Data Integrity Failures, 9) Logging/Monitoring Failures, 10) Server-Side Request Forgery (SSRF). Prévention : formation équipe, code review sécurisé, outils SAST/DAST, pentesting régulier, veille vulnérabilités, framework sécurisé."
    },
    {
      "question": "Comment fonctionne l'authentification avec JWT ?",
      "answer": "JWT (JSON Web Token) fonctionne ainsi : 1) L'utilisateur s'authentifie avec ses identifiants, 2) Le serveur vérifie et génère un token JWT signé contenant des claims (user ID, rôles, expiration), 3) Le client stocke le token (localStorage/sessionStorage), 4) Pour chaque requête, le client envoie le token dans l'header Authorization: Bearer <token>, 5) Le serveur vérifie la signature et l'expiration, 6) Si valide, la requête est autorisée. Avantages : stateless, scalable, sécurisé."
    },
    {
      "question": "Comment gérer les autorisations côté backend avec Spring Boot ?",
      "answer": "Autorisations Spring Boot : 1) Spring Security avec @EnableGlobalMethodSecurity, 2) Annotations @PreAuthorize, @PostAuthorize, @Secured, 3) Configuration WebSecurityConfigurer, 4) Roles et Authorities via UserDetails, 5) ACL (Access Control Lists) pour granularité fine, 6) JWT Claims pour rôles, 7) Method-level security, 8) SpEL expressions pour logique complexe. Exemple : @PreAuthorize('hasRole(\"ADMIN\") or #userId == authentication.name'). Tests avec @WithMockUser."
    },
    {
      "question": "Pourquoi activer CORS dans une API backend ?",
      "answer": "CORS (Cross-Origin Resource Sharing) nécessaire car : Same-Origin Policy bloque requêtes inter-domaines par défaut pour sécurité. CORS permet : 1) Frontend et API sur domaines différents, 2) SPAs consommant APIs tierces, 3) Microservices architecture, 4) CDN et assets externes. Configuration : headers Access-Control-Allow-Origin, Allow-Methods, Allow-Headers. Spring : @CrossOrigin ou WebMvcConfigurer. Production : domaines spécifiques, pas de wildcard '*'."
    },
    {
      "question": "Pourquoi un token JWT doit-il avoir une durée de vie limitée ?",
      "answer": "JWT avec expiration courte pour : 1) Limiter impact en cas de vol/fuite, 2) Rotation sécurisée des credentials, 3) Révocation possible via refresh tokens, 4) Compliance réglementaire, 5) Principe de moindre exposition. Stratégie : access token court (15min-1h) + refresh token long (7-30j). Stockage sécurisé : httpOnly cookies > localStorage. Monitoring des tokens expirés/suspects. Balance entre sécurité et UX."
    },
    {
      "question": "Comment sécuriser une API avec OAuth2 et JWT ?",
      "answer": "OAuth2 + JWT architecture : 1) Authorization Server émet JWT après authentification, 2) Resource Server valide JWT signature et claims, 3) Scopes pour granularité permissions, 4) PKCE pour clients publics, 5) State parameter anti-CSRF, 6) TLS obligatoire, 7) Rotation des secrets, 8) Audit logs détaillés. Flows : Authorization Code (SPAs), Client Credentials (M2M). Libraries : Spring Security OAuth2, Auth0. Tests : mock JWT, test authorizations scenarios."
    },
    {
      "question": "Quelle est la différence entre le JDK et la JVM ?",
      "answer": "JVM (Java Virtual Machine) : environnement d'exécution qui interprète et exécute le bytecode Java, assure la portabilité 'Write Once, Run Anywhere', gère la mémoire et le garbage collection. JDK (Java Development Kit) : kit de développement complet qui inclut la JVM, le compilateur javac, les outils de développement (debugger, javadoc), les bibliothèques standard, et les APIs. En résumé : JDK = outils de développement + JVM, JVM = environnement d'exécution uniquement."
    },
    {
      "question": "Quelles sont les bonnes pratiques pour concevoir une API RESTful bien structurée ?",
      "answer": "API RESTful bien conçue : 1) Noms de ressources substantifs (users, orders), 2) HTTP verbs appropriés (GET, POST, PUT, DELETE), 3) Structure URLs hiérarchique (/users/123/orders), 4) Codes de statut HTTP précis, 5) Versioning dans URL ou headers, 6) Pagination, filtrage, tri, 7) HATEOAS pour discoverability, 8) Documentation OpenAPI/Swagger, 9) Validation et gestion d'erreurs consistantes, 10) Cache headers, 11) Rate limiting, 12) Tests automatisés complets."
    },
    {
      "question": "Quelles sont les différences fondamentales entre REST et GraphQL ?",
      "answer": "REST vs GraphQL : REST : multiple endpoints, over/under-fetching possible, cache HTTP natif, maturité élevée, simplicité conceptuelle. GraphQL : endpoint unique, requête précise des données, résolution N+1 potential, cache complexe, courbe apprentissage. REST meilleur pour : APIs simples, cache HTTP, équipes junior. GraphQL meilleur pour : clients multiples, données complexes, développement rapide frontend. Choisir selon : complexité données, équipe, performance requirements, écosystème existant."
    },
    {
      "question": "Quelles stratégies utiliser pour le versionnement et la compatibilité des APIs ?",
      "answer": "Stratégies versioning API : 1) URL versioning (/v1/users, /v2/users), 2) Header versioning (Accept: application/vnd.api+json;version=1), 3) Query parameter (?version=1), 4) Semantic versioning (major.minor.patch). Compatibilité : 1) Backward compatibility stricte, 2) Deprecation warnings, 3) Sunset headers, 4) Transition periods, 5) Documentation migration guides, 6) Feature flags, 7) Contract testing. Éviter breaking changes, privilegier évolution additive."
    },
    {
      "question": "Comment tester efficacement les endpoints d'une API (unitaires et intégration) ?",
      "answer": "Tests API multicouches : Unitaires : services isolés, mocks dépendances, logique métier pure. Intégration : @SpringBootTest, TestContainers pour DB, MockMvc pour HTTP layer. Contrat : Pact testing entre consumer/provider. E2E : Rest Assured, Postman/Newman. Stratégie : pyramide tests, données de test isolées, CI/CD integration, monitoring production. Outils : JUnit, Mockito, WireMock, TestContainers. Coverage : happy path + edge cases + error scenarios."
    }
  ],
  "database": [
    {
      "question": "Quelle est la différence entre un schéma conceptuel, un schéma logique et un schéma physique ?",
      "answer": "Schéma conceptuel : vue métier de haut niveau, indépendante de la technologie, modélise les entités et relations (MCD en Merise). Schéma logique : traduction du conceptuel vers un modèle de données spécifique (relationnel, NoSQL), définit tables, colonnes, contraintes (MLD en Merise). Schéma physique : implémentation technique réelle, inclut indexes, partitioning, storage, optimisations de performance (MPD en Merise). Chaque niveau ajoute des détails techniques progressivement."
    },
    {
      "question": "Quelle est la différence entre une clé primaire et une clé étrangère ?",
      "answer": "Clé primaire : identifiant unique pour chaque ligne d'une table, ne peut pas être NULL, une seule par table, assure l'intégrité d'entité. Exemple : user_id dans table Users. Clé étrangère : référence à la clé primaire d'une autre table, peut être NULL (sauf si NOT NULL), plusieurs par table, assure l'intégrité référentielle. Exemple : user_id dans table Orders qui référence Users.user_id. Les clés étrangères maintiennent la cohérence des relations entre tables."
    },
    {
      "question": "Quelles sont les principales étapes de la méthode Merise pour concevoir une base de données ?",
      "answer": "Méthode Merise : 1) Analyse des besoins et règles de gestion, 2) MCD (Modèle Conceptuel de Données) : entités, associations, cardinalités, 3) MLD (Modèle Logique de Données) : transformation en tables relationnelles, 4) MPD (Modèle Physique de Données) : implémentation SGBD spécifique, optimisations. Parallèlement : MCT (flux), MOT (organisation), MPT (technique). Validation à chaque étape, itérations possibles. Résultat : base de données normalisée et optimisée."
    },
    {
      "question": "Quelle est la différence entre une association 1-1, 1-N et N-N dans Merise ?",
      "answer": "Associations Merise : 1-1 (un-à-un) : une occurrence d'entité liée à une seule occurrence de l'autre (Personne-Passeport). 1-N (un-à-plusieurs) : une occurrence liée à plusieurs (Client-Commandes). N-N (plusieurs-à-plusieurs) : plusieurs occurrences liées à plusieurs (Étudiants-Cours). Implémentation : 1-1 et 1-N = clé étrangère, N-N = table d'association intermédiaire. Cardinalités précisent la participation (0,1 ou 1,1 ou 0,N ou 1,N)."
    },
    {
      "question": "Comment construire et modéliser une base de données relationnelle efficace ?",
      "answer": "Base de données efficace : 1) Analyse métier approfondie, 2) Normalisation (3NF minimum), 3) Choix types de données appropriés, 4) Index stratégiques, 5) Contraintes d'intégrité, 6) Dénormalisation contrôlée si nécessaire, 7) Partitioning pour gros volumes, 8) Archivage des données anciennes, 9) Tests de performance, 10) Documentation complète. Outils : ERwin, PowerDesigner, MySQL Workbench. Validation avec cas d'usage réels."
    },
    {
      "question": "Comment créer une base de données en SQL ?",
      "answer": "Pour créer une base de données en SQL : CREATE DATABASE nom_base_donnees; puis USE nom_base_donnees; pour l'utiliser. Options avancées : CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; pour l'encodage. Exemple complet : CREATE DATABASE ecommerce CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; Bonnes pratiques : utiliser des noms explicites, définir l'encodage, planifier la structure, prévoir les droits d'accès."
    },
    {
      "question": "Comment créer une table avec une clé primaire et une clé étrangère ?",
      "answer": "Création table SQL : CREATE TABLE users (id INT PRIMARY KEY AUTO_INCREMENT, nom VARCHAR(100) NOT NULL, email VARCHAR(255) UNIQUE); CREATE TABLE orders (id INT PRIMARY KEY AUTO_INCREMENT, user_id INT, amount DECIMAL(10,2), FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE); Contraintes : NOT NULL, UNIQUE, CHECK. Options FK : CASCADE, SET NULL, RESTRICT. Index automatique sur PK, recommandé sur FK."
    },
    {
      "question": "Comment protéger une base de données contre les injections SQL ?",
      "answer": "Protection contre l'injection SQL : 1) Requêtes préparées (prepared statements) - séparent code et données, 2) Validation stricte des entrées côté serveur, 3) Échappement des caractères spéciaux, 4) Utilisation d'un ORM (Hibernate, Doctrine), 5) Principe de moindre privilège pour les comptes DB, 6) Stored procedures avec paramètres, 7) Whitelist validation plutôt que blacklist, 8) Tests de sécurité réguliers, 9) Never trust user input."
    },
    {
      "question": "Quelles sont les stratégies d'optimisation des performances des bases de données SQL ?",
      "answer": "Optimisation performance SQL : 1) Index appropriés (B-tree, Hash, Bitmap), 2) Requêtes optimisées (EXPLAIN), 3) Dénormalisation contrôlée, 4) Partitioning horizontal/vertical, 5) Cache query results, 6) Connection pooling, 7) Maintenance régulière (ANALYZE, VACUUM), 8) Archivage données anciennes, 9) Hardware adapté (SSD, RAM), 10) Monitoring continu (slow query log). Mesurer avant/après optimisations."
    },
    {
      "question": "Quelles sont les meilleures pratiques pour optimiser les requêtes SQL et NoSQL ?",
      "answer": "Optimisation requêtes : SQL : 1) Index sur colonnes WHERE/JOIN, 2) Éviter SELECT *, 3) LIMIT pour pagination, 4) EXISTS vs IN selon contexte, 5) Analyze query plans. NoSQL : 1) Design orienté requêtes, 2) Index composés, 3) Sharding strategy, 4) Éviter cross-shard queries, 5) Projection fields appropriées. Général : cache, batch operations, monitoring performance, load testing. Outils : EXPLAIN, profilers, APM."
    },
    {
      "question": "Quelles sont les bonnes pratiques pour sécuriser une base de données et gérer les comptes utilisateurs ?",
      "answer": "Sécurisation base de données : 1) Comptes nominatifs avec mots de passe forts, 2) Principe de moindre privilège, 3) Rôles et permissions granulaires, 4) Rotation des mots de passe, 5) Audit des accès, 6) Chiffrement en transit (TLS) et au repos, 7) Sauvegarde chiffrées, 8) Monitoring des connexions suspectes, 9) Réseau sécurisé (VPN, firewall), 10) Maintenance sécurité régulière, 11) Formation équipes. Éviter comptes partagés."
    },
    {
      "question": "Pourquoi ne faut-il pas utiliser root pour les accès à la base de données ?",
      "answer": "Éviter root car : 1) Principe de moindre privilège violé, 2) Audit impossible (actions non traçables), 3) Risque sécuritaire énorme si compromis, 4) Pas de granularité des permissions, 5) Violation des standards sécurité, 6) Impossibilité de révoquer accès spécifiques, 7) Non-conformité réglementaire. Solution : comptes dédiés par application/utilisateur avec permissions minimales nécessaires. Root réservé aux tâches administratives ponctuelles."
    },
    {
      "question": "Pourquoi faut-il toujours valider les entrées utilisateur avant d'insérer des données en base ?",
      "answer": "Validation entrées obligatoire pour : 1) Prévention injection SQL, 2) Intégrité des données métier, 3) Cohérence format/type, 4) Respect contraintes DB, 5) Performance (éviter rollbacks), 6) Audit et conformité, 7) UX (messages d'erreur clairs), 8) Stabilité système. Validation multicouche : frontend (UX), backend (sécurité), database (intégrité). Never trust client data. Logs des tentatives malveillantes."
    },
    {
      "question": "Comment sécuriser les accès aux bases de données SQL et NoSQL ?",
      "answer": "Sécurisation accès DB : 1) Authentification forte (certificats, 2FA), 2) Autorisation granulaire (RBAC), 3) Chiffrement connexions (TLS/SSL), 4) VPN ou réseaux privés, 5) Firewall DB niveau réseau, 6) Rate limiting connexions, 7) Monitoring et alertes, 8) Audit logs détaillés, 9) Backup chiffrées hors site, 10) Patching sécurité régulier. NoSQL : attention aux configurations par défaut non sécurisées."
    },
    {
      "question": "Comment tester la sécurité et l'intégrité des accès aux bases de données ?",
      "answer": "Tests sécurité DB : 1) Tests d'intrusion automatisés, 2) Audit des permissions et rôles, 3) Vérification chiffrement, 4) Tests injection SQL/NoSQL, 5) Monitoring des accès anormaux, 6) Validation sauvegarde/restore, 7) Tests de performance sous charge, 8) Compliance checks (GDPR, PCI), 9) Penetration testing, 10) Code review accès données. Outils : SQLMap, OWASP ZAP, Nessus. Tests réguliers en CI/CD."
    },
    {
      "question": "Qu'est-ce qu'un ORM et pourquoi l'utiliser ?",
      "answer": "ORM (Object-Relational Mapping) : technique de programmation qui fait le lien entre objets métier et tables de base de données. Avantages : 1) Abstraction de la DB, code plus maintenable, 2) Protection contre l'injection SQL, 3) Portabilité entre différents SGBD, 4) Génération automatique des requêtes, 5) Gestion des relations complexes, 6) Cache de premier niveau. Inconvénients : courbe d'apprentissage, performance parfois moindre, requêtes N+1. Exemples : Hibernate (Java), Doctrine (PHP), Eloquent (Laravel)."
    },
    {
      "question": "Comment JPA crée-t-il la base et les tables dans Spring Boot ?",
      "answer": "JPA/Spring Boot création automatique : 1) spring.jpa.hibernate.ddl-auto=create/update/validate, 2) Annotations @Entity sur classes, 3) @Table pour noms spécifiques, 4) @Id @GeneratedValue pour PK, 5) @Column pour contraintes, 6) @OneToMany, @ManyToOne pour relations, 7) schema.sql pour initialisation, 8) data.sql pour données test. Environnements : create en dev, validate en prod. Attention : create DROP les tables ! Migrations Flyway/Liquibase en production."
    },
    {
      "question": "Comment accéder aux données avec JPA dans Spring Boot ?",
      "answer": "Accès données JPA Spring Boot : 1) Repository interfaces (CrudRepository, JpaRepository), 2) Méthodes de requête dérivées (findByName), 3) @Query pour requêtes personnalisées JPQL/SQL, 4) @Modifying pour UPDATE/DELETE, 5) Pagination avec Pageable, 6) Spécifications pour requêtes dynamiques, 7) @Transactional pour transactions, 8) EntityManager pour contrôle fin. Exemple : List<User> findByAgeGreaterThan(int age); Performance : Lazy loading, projections."
    },
    {
      "question": "Comment configurer la connexion à une base MySQL avec Spring Boot ?",
      "answer": "Configuration MySQL Spring Boot : application.properties : spring.datasource.url=jdbc:mysql://localhost:3306/mydb, spring.datasource.username=user, spring.datasource.password=password, spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver, spring.jpa.hibernate.ddl-auto=update, spring.jpa.show-sql=true. Dépendance Maven : mysql-connector-java. Pool connexions : HikariCP par défaut. Sécurité : variables d'environnement pour credentials, SSL si nécessaire."
    },
    {
      "question": "Comment JPA fait-il le lien entre une classe Java et une table en base de données ?",
      "answer": "Mapping JPA classe-table : 1) @Entity marque la classe persistante, 2) @Table(name=\"users\") spécifie nom table, 3) @Id identifie la clé primaire, 4) @Column(name=\"email\", unique=true) map attribut-colonne, 5) @GeneratedValue pour auto-increment, 6) @Temporal pour dates, 7) @Enumerated pour enums, 8) Relations @OneToMany/@ManyToOne, 9) @JoinColumn pour FK. Convention over configuration : User -> user table par défaut."
    },
    {
      "question": "Quelle est la différence entre une base de données SQL et NoSQL ?",
      "answer": "SQL (Relationnel) : structure tabulaire avec schéma fixe, ACID compliance, relations complexes, langage SQL standardisé, excellente consistance. Exemples : MySQL, PostgreSQL. NoSQL : schéma flexible, types variés (document, clé-valeur, graphe, colonne), scale horizontal naturel, performance élevée, eventual consistency. Exemples : MongoDB (document), Redis (clé-valeur), Cassandra (colonne), Neo4j (graphe). Choix selon : complexité des relations, volume de données, besoins de consistance, équipe de développement."
    },
    {
      "question": "Quels sont les avantages et inconvénients des procédures stockées et des triggers ?",
      "answer": "Procédures stockées : Avantages : performance (pré-compilées), sécurité (permissions granulaires), logique centralisée, réduction trafic réseau. Inconvénients : portabilité limitée, versioning complexe, debugging difficile, couplage fort DB. Triggers : Avantages : intégrité automatique, audit transparent, règles métier centralisées. Inconvénients : debugging complexe, performance impact, logique cachée, cascade effects. Usage : procédures pour traitements complexes, triggers pour contraintes business critiques."
    },
    {
      "question": "Quels sont les principaux Design Patterns pour l'accès aux bases de données et leur utilité ?",
      "answer": "Design Patterns accès données : 1) Repository : abstraction couche accès, testabilité, 2) DAO (Data Access Object) : encapsulation logique persistance, 3) Unit of Work : gestion transactions, cohérence, 4) Active Record : objet = enregistrement, simplicité, 5) Data Mapper : séparation objet/DB, flexibilité, 6) Query Object : requêtes réutilisables, 7) Connection Pool : performance connexions. Choix selon complexité, performance, testabilité. Spring Data Repository populaire."
    },
    {
      "question": "Pourquoi intégrer l'authentification et la gestion des accès dans les composants d'accès aux données ?",
      "answer": "Sécurité intégrée accès données pour : 1) Defense in depth, 2) Autorisation granulaire par donnée, 3) Audit trail complet, 4) Prévention élévation privilèges, 5) Compliance réglementaire, 6) Isolation multi-tenant. Implémentation : Spring Security method-level, Row Level Security PostgreSQL, filtres dynamiques, aspects AOP. Exemples : @PreAuthorize sur repositories, filtres utilisateur automatiques, logging accès sensibles. Équilibre sécurité/performance."
    }
  ],
  "devops": [
    {
      "question": "Pourquoi utiliser Docker pour un projet ?",
      "answer": "Docker apporte : 1) Isolation des applications dans des conteneurs légers, 2) Reproductibilité : 'ça marche sur ma machine' → 'ça marche partout', 3) Portabilité entre environnements (dev, test, prod), 4) Scalabilité horizontale facilitée, 5) Gestion simplifiée des dépendances, 6) Déploiement rapide et rollback facile, 7) Optimisation des ressources vs VMs, 8) Intégration CI/CD, 9) Microservices architecture, 10) Cohérence des environnements équipe."
    },
    {
      "question": "Quels fichiers sont nécessaires pour configurer un conteneur Docker ?",
      "answer": "Fichiers Docker essentiels : 1) Dockerfile : instructions de build (FROM, RUN, COPY, EXPOSE, CMD), 2) .dockerignore : exclusions du contexte build, 3) docker-compose.yml : orchestration multi-conteneurs, 4) docker-compose.override.yml : surcharges développement. Optionnels : entrypoint.sh (script démarrage), healthcheck scripts, variables d'environnement (.env). Structure typique : base image → dépendances → code application → configuration runtime."
    },
    {
      "question": "Pourquoi utiliser Docker dans une démarche DevOps ?",
      "answer": "Docker + DevOps = synergie parfaite : 1) Standardisation environnements dev→prod, 2) CI/CD simplifié avec images versionnées, 3) Déploiements automatisés et reproductibles, 4) Rollback instantané, 5) Scaling horizontal facilité, 6) Infrastructure as Code, 7) Monitoring unifié, 8) Tests en environnements identiques, 9) Réduction Time-to-Market, 10) Collaboration Dev/Ops améliorée. Élimination 'configuration drift' entre environnements."
    },
    {
      "question": "Qu'est-ce que docker-compose et pourquoi l'utiliser ?",
      "answer": "Docker Compose : outil d'orchestration multi-conteneurs avec fichier YAML déclaratif. Utilité : 1) Définition architecture complète (app, DB, cache, proxy), 2) Gestion des réseaux et volumes, 3) Variables d'environnement centralisées, 4) Commandes simples (up, down, scale), 5) Environnements reproductibles, 6) Développement local simplifié. Exemple : web app + PostgreSQL + Redis en une commande. Alternative : Kubernetes pour production complexe."
    },
    {
      "question": "Quels sont les avantages de Docker et comment l'utiliser dans un projet ?",
      "answer": "Avantages Docker : isolation, portabilité, efficacité ressources, versioning, scaling. Utilisation projet : 1) Dockerfile pour chaque service, 2) Multi-stage builds (build/runtime séparés), 3) Base images officielles sécurisées, 4) Secrets management, 5) Health checks, 6) Resource limits, 7) Logging centralisé, 8) Registry privé, 9) Scanning sécurité images, 10) Documentation Dockerfile. Best practices : layers minimales, user non-root, images lightweight."
    },
    {
      "question": "Comment Kubernetes facilite-t-il l'orchestration des conteneurs ?",
      "answer": "Kubernetes orchestration : 1) Déploiement automatisé (Deployments, StatefulSets), 2) Service discovery et load balancing, 3) Auto-scaling horizontal/vertical, 4) Rolling updates sans downtime, 5) Health checks et self-healing, 6) Gestion configuration (ConfigMaps, Secrets), 7) Persistence volumes, 8) Network policies, 9) RBAC sécurité, 10) Multi-cloud portabilité. Abstraction infrastructure, état désiré déclaratif, écosystème riche (Helm, Operators)."
    },
    {
      "question": "Comment mettre en place une pipeline CI/CD efficace ?",
      "answer": "Pipeline CI/CD efficace : 1) Source Control (Git) avec branches stratégiques, 2) CI : build automatique, tests unitaires/intégration, analyse qualité code (SonarQube), 3) Artefacts : création et stockage des builds, 4) CD : déploiement automatisé par environnement (dev→test→prod), 5) Tests automatisés (E2E, performance), 6) Monitoring et alertes, 7) Rollback automatique si échec, 8) Documentation et notifications équipe. Outils : Jenkins, GitLab CI, GitHub Actions, Azure DevOps."
    },
    {
      "question": "Qu'est-ce que DevOps et pourquoi l'utiliser ?",
      "answer": "DevOps est une culture et ensemble de pratiques qui rapprochent le développement (Dev) et les opérations (Ops) pour : 1) Accélérer la livraison de logiciels, 2) Améliorer la collaboration entre équipes, 3) Automatiser les processus (CI/CD), 4) Réduire les erreurs humaines, 5) Feedback rapide et amélioration continue, 6) Monitoring et observabilité, 7) Infrastructure as Code, 8) Déploiements fréquents et fiables. Bénéfices : time-to-market réduit, qualité améliorée, satisfaction client."
    },
    {
      "question": "Quelle est la différence entre Intégration Continue (CI) et Déploiement Continu (CD) ?",
      "answer": "CI (Continuous Integration) : pratique de merger fréquemment le code dans la branche principale, avec build et tests automatiques à chaque commit. Objectif : détecter les problèmes tôt. CD (Continuous Deployment/Delivery) : extension de CI qui automatise le déploiement. Continuous Delivery : code prêt à déployer, déploiement manuel. Continuous Deployment : déploiement automatique en production si tous les tests passent. CI assure la qualité, CD assure la livraison rapide."
    },
    {
      "question": "Quels outils sont utilisés pour la CI/CD ?",
      "answer": "Outils CI/CD populaires : 1) Jenkins : open-source, extensible, plugins nombreux, 2) GitLab CI : intégré Git, containers natifs, 3) GitHub Actions : workflows YAML, marketplace, 4) Azure DevOps : Microsoft ecosystem, 5) CircleCI : cloud-native, performance, 6) TeamCity : JetBrains, intégration IDE. Critères choix : écosystème existant, complexité pipelines, coûts, support équipe, intégrations tierces. Tendance : cloud-native solutions."
    },
    {
      "question": "Pourquoi automatiser les tests dans une CI/CD ?",
      "answer": "Automatisation tests CI/CD critique pour : 1) Détection précoce des régressions, 2) Feedback rapide développeurs, 3) Qualité constante releases, 4) Confiance déploiements, 5) Réduction coûts bugs production, 6) Vélocité équipe maintenue, 7) Documentation comportements attendus, 8) Non-régression fonctionnelle. Tests : unitaires (rapides), intégration (contrats), E2E (parcours critiques), performance (seuils). Gate qualité avant déploiement."
    },
    {
      "question": "Que contient un fichier CI/CD (.yaml) pour GitHub Actions ?",
      "answer": "Fichier GitHub Actions (.github/workflows/ci.yml) : name, on: [push, pull_request], jobs avec runs-on (ubuntu-latest), steps avec uses/run, actions marketplace (checkout, setup-node, cache), variables d'environnement, secrets, artifacts, matrix builds, conditions. Exemple : checkout code → setup environment → install dependencies → run tests → build → deploy. Workflows parallèles, réutilisables, intégration status checks."
    },
    {
      "question": "Qu'est-ce que le déploiement d'une application ?",
      "answer": "Déploiement application : processus de mise en production du code depuis l'environnement de développement. Étapes : 1) Build de l'application, 2) Tests qualité/sécurité, 3) Packaging (Docker, JAR, etc.), 4) Configuration environnement cible, 5) Transfert artefacts, 6) Installation/mise à jour, 7) Configuration runtime, 8) Démarrage services, 9) Tests post-déploiement, 10) Monitoring. Stratégies : blue-green, rolling, canary. Automatisation recommandée."
    },
    {
      "question": "Quelle est la différence entre un serveur et un hébergeur ?",
      "answer": "Serveur : machine physique/virtuelle exécutant des applications et services. Hébergeur : entreprise fournissant infrastructure (serveurs, réseau, sécurité, maintenance). Types hébergement : 1) Mutualisé : ressources partagées, économique, 2) Dédié : serveur exclusif, performance max, 3) VPS : virtuel isolé, équilibre prix/performance, 4) Cloud : élastique, pay-as-you-use. Serveur = hardware/software, Hébergeur = service provider."
    },
    {
      "question": "Qu'est-ce qu'un DNS et quel est son rôle ?",
      "answer": "DNS (Domain Name System) : système de résolution de noms de domaine en adresses IP. Rôle : 1) Traduction google.com → 172.217.14.110, 2) Hiérarchie distributée (root → TLD → autoritaire), 3) Cache pour performance, 4) Redondance et fiabilité, 5) Load balancing par rotation, 6) Géolocalisation traffic. Types d'enregistrements : A (IPv4), AAAA (IPv6), CNAME (alias), MX (mail), TXT (métadonnées). Essentiel pour navigation web."
    },
    {
      "question": "Qu'est-ce qu'un reverse proxy et pourquoi l'utiliser ?",
      "answer": "Un reverse proxy (ex: Nginx, HAProxy) se place devant les serveurs d'application et agit au nom du serveur. Fonctions : 1) Load balancing : distribue les requêtes entre plusieurs serveurs, 2) SSL termination : gère le chiffrement HTTPS, 3) Cache : stocke les réponses statiques, 4) Compression : réduit la bande passante, 5) Sécurité : filtre les requêtes malveillantes, 6) Rate limiting, 7) Health checks des serveurs backend. Améliore performance, sécurité et disponibilité."
    },
    {
      "question": "Comment gérer efficacement le versionnement et les mises à jour d'un logiciel ?",
      "answer": "Versionnement efficace : 1) Semantic Versioning (MAJOR.MINOR.PATCH), 2) Git flow ou GitHub flow, 3) Tags pour releases, 4) Changelog détaillé, 5) Branches de maintenance LTS, 6) Tests automatisés complets, 7) Déploiements progressifs (canary, blue-green), 8) Rollback strategy, 9) Communication utilisateurs, 10) Monitoring post-release. Mises à jour : backward compatibility, migration scripts, documentation."
    },
    {
      "question": "Quelles stratégies adopter pour une migration de logiciel sans rupture ?",
      "answer": "Migration sans rupture : 1) Strangler Pattern : remplacement progressif, 2) Blue-Green Deployment : environnements parallèles, 3) Feature Flags : activation contrôlée, 4) Database migration scripts, 5) API versioning pour compatibilité, 6) Tests de charge avant switch, 7) Rollback plan détaillé, 8) Communication stakeholders, 9) Formation équipes, 10) Monitoring intensif. Phase pilote, feedback users, validation métier. Patience et planification."
    },
    {
      "question": "Qu'est-ce que l'Infrastructure as Code et quels outils utiliser (Terraform, Ansible…) ?",
      "answer": "Infrastructure as Code (IaC) : gestion infrastructure via code déclaratif versionné. Avantages : reproductibilité, versioning, collaboration, automatisation. Outils : 1) Terraform : multi-cloud, state management, 2) Ansible : configuration management, agentless, 3) CloudFormation : AWS natif, 4) Pulumi : langages de programmation, 5) Chef/Puppet : configuration complexe. Choisir selon : cloud provider, équipe skills, complexité infrastructure. Best practices : modules, testing, state remote."
    },
    {
      "question": "Quels outils recommandes-tu pour la supervision et la gestion des logs en production ?",
      "answer": "Monitoring et logs production : 1) APM : New Relic, Datadog, AppDynamics pour performance applicative, 2) Infrastructure : Prometheus + Grafana, Nagios, Zabbix, 3) Logs : ELK Stack (Elasticsearch, Logstash, Kibana), Splunk, Fluentd, 4) Alerting : PagerDuty, OpsGenie, 5) Synthetics : tests user journey, 6) Cloud-native : CloudWatch, Azure Monitor. Centralisation, corrélation, alertes intelligentes, dashboards métier."
    },
    {
      "question": "Quels outils de monitoring et de logging recommandes-tu pour suivre les performances d'une application ?",
      "answer": "Stack monitoring moderne : 1) Métriques : Prometheus (collecte) + Grafana (visualisation), 2) Traces distribuées : Jaeger, Zipkin pour microservices, 3) Logs : ELK/EFK stack, Loki, 4) APM : New Relic, Datadog, Dynatrace pour code-level insights, 5) Synthetics : Pingdom, Uptime Robot, 6) Real User Monitoring (RUM), 7) Infrastructure : Node Exporter, cAdvisor. Corrélation métriques/logs/traces cruciale pour troubleshooting."
    },
    {
      "question": "Quelles sont les stratégies de mise en cache pour améliorer les performances d'une application ?",
      "answer": "Stratégies cache multicouche : 1) Browser cache : CSS/JS/images avec Cache-Control, 2) CDN : géodistribution contenu statique, 3) Reverse proxy cache : Varnish, Nginx, 4) Application cache : Redis, Memcached pour données fréquentes, 5) Database query cache, 6) Object cache : ORM L1/L2, 7) HTTP cache : ETags, Last-Modified. Patterns : cache-aside, write-through, write-behind. Invalidation strategy cruciale. Mesurer hit ratio."
    },
    {
      "question": "Comment fonctionne le load balancing et quand l'utiliser ?",
      "answer": "Le load balancing distribue le trafic entre plusieurs serveurs selon différents algorithmes : Round Robin (rotation), Least Connections (moins de connexions), IP Hash (basé sur IP client), Weighted (pondéré par capacité). Types : Layer 4 (transport) ou Layer 7 (application). Utiliser quand : 1) Trafic élevé dépassant un serveur, 2) Besoin de haute disponibilité, 3) Architecture microservices, 4) Maintenance sans interruption, 5) Scaling horizontal. Outils : AWS ALB/NLB, Nginx, HAProxy, Cloudflare."
    }
  ],
  "architecture": [
    {
      "question": "Quels sont les principes des architectures logicielles multicouches ?",
      "answer": "Architecture multicouches (n-tier) organise l'application en couches distinctes : 1) Présentation : interface utilisateur (UI/UX), 2) Logique métier : règles de gestion et traitements, 3) Accès aux données : persistance et récupération. Principes : séparation des responsabilités, couplage faible, cohésion forte, réutilisabilité, maintenabilité. Chaque couche ne communique qu'avec les couches adjacentes. Avantages : modularité, testabilité, évolutivité, équipes spécialisées."
    },
    {
      "question": "Quel est l'intérêt d'une architecture en couches ?",
      "answer": "Architecture en couches bénéfique pour : 1) Séparation des responsabilités claire, 2) Réutilisabilité des composants, 3) Maintenance facilitée par isolation, 4) Tests indépendants par couche, 5) Évolutivité contrôlée, 6) Équipes spécialisées par couche, 7) Sécurité renforcée (defense in depth), 8) Performance optimisable par couche, 9) Documentation simplifiée, 10) Respect des standards architecturaux. Facilite compréhension et maintenance long terme."
    },
    {
      "question": "Quelle est la différence entre une architecture monolithique et une architecture en microservices ?",
      "answer": "Monolithique : application déployée comme une seule unité, toutes les fonctionnalités dans un même processus. Avantages : simplicité développement/déploiement, performance interne élevée. Inconvénients : scaling difficile, technologies figées, risque de panne globale. Microservices : application découpée en services indépendants communicant par APIs. Avantages : scaling granulaire, technologies variées, résilience, équipes autonomes. Inconvénients : complexité réseau, gestion distribuée, debugging complexe. Choix selon taille équipe et complexité métier."
    },
    {
      "question": "Quelles sont les principales couches d'une architecture logicielle multicouche ?",
      "answer": "Couches architecture multicouche typique : 1) Présentation : UI, contrôleurs, formatage données, 2) Application/Service : orchestration, workflows, APIs, 3) Métier/Domaine : règles business, entités, logique core, 4) Persistance/Données : repositories, DAO, mapping ORM, 5) Infrastructure : base de données, filesystem, services externes. Variantes : MVC, MVP, MVVM, Clean Architecture, Hexagonal. Communication unidirectionnelle descendante recommandée."
    },
    {
      "question": "Quels sont les principes d'architecture d'une application SaaS et leurs avantages ?",
      "answer": "Architecture SaaS : 1) Multi-tenancy : isolation données clients, 2) Élasticité : scaling automatique, 3) API-first : intégrations facilitées, 4) Microservices : déploiements indépendants, 5) Event-driven : asynchrone, découplage, 6) Cloud-native : containers, orchestration, 7) Security by design : chiffrement, RBAC, 8) Observabilité : monitoring, logs, metrics. Avantages : coûts réduits, mises à jour centralisées, accessibilité globale, scalabilité, time-to-market rapide."
    },
    {
      "question": "Comment sécuriser une architecture logicielle ?",
      "answer": "Sécurisation architecture : 1) Defense in depth : sécurité multicouche, 2) Principe de moindre privilège, 3) Zero Trust : vérifier tout, ne rien supposer, 4) Chiffrement en transit (HTTPS) et au repos, 5) Authentification forte et autorisation granulaire, 6) Segmentation réseau et firewalls, 7) Logs centralisés et monitoring, 8) Gestion des secrets (Vault), 9) Updates sécurité régulières, 10) Tests de pénétration, 11) Backup et plan de continuité, 12) Formation équipes sécurité."
    },
    {
      "question": "Quelles sont les principales vulnérabilités des architectures multicouches et comment les prévenir ?",
      "answer": "Vulnérabilités multicouches : 1) Injection attacks (SQL, NoSQL, LDAP) → prepared statements, validation, 2) Broken authentication → MFA, session management, 3) Data exposure → chiffrement, access control, 4) API abuse → rate limiting, validation, 5) Privilege escalation → RBAC, audit, 6) Man-in-the-middle → TLS, certificate pinning. Prévention : security by design, code reviews, SAST/DAST tools, penetration testing, security training."
    },
    {
      "question": "Comment adapter une architecture logicielle aux exigences de sécurité de l'ANSSI ?",
      "answer": "Conformité ANSSI : 1) Référentiel RGS (Référentiel Général de Sécurité), 2) Classification données (DR, Confidentiel, Secret), 3) Homologation sécurité obligatoire, 4) Chiffrement qualifié (algorithmes ANSSI), 5) Architecture cloisonnée, 6) Audit et traçabilité, 7) Plan de continuité/reprise, 8) Formation personnels habilités, 9) Gestion des incidents, 10) Revues sécurité régulières. Documentation détaillée, tests conformité, certification produits."
    },
    {
      "question": "Quels sont les principaux indicateurs de sécurité des systèmes d'information (DICP) ?",
      "answer": "DICP (Disponibilité, Intégrité, Confidentialité, Preuve) : 1) Disponibilité : uptime, RTO/RPO, redondance, 2) Intégrité : checksums, signatures numériques, contrôles cohérence, 3) Confidentialité : chiffrement, access control, classification, 4) Preuve/Non-répudiation : signatures, audit trails, timestamps. Métriques : taux incidents, temps résolution, niveau conformité, coûts sécurité. Balance entre sécurité et usabilité selon criticité métier."
    },
    {
      "question": "Quels outils peux-tu utiliser pour modéliser une architecture logicielle ?",
      "answer": "Outils de modélisation architecture : 1) UML : diagrammes de composants, déploiement, séquence (Lucidchart, Draw.io), 2) C4 Model : Context, Containers, Components, Code (PlantUML, Structurizr), 3) ArchiMate : framework enterprise (Archi, BiZZdesign), 4) Diagrammes d'architecture cloud (AWS/Azure/GCP tools), 5) Miro/Mural pour ateliers collaboratifs, 6) Enterprise Architect pour grandes organisations, 7) Draw.io gratuit et efficace, 8) Visio Microsoft. Important : choisir selon audience et niveau de détail requis."
    },
    {
      "question": "Quels principes d'éco-conception peux-tu appliquer dans une architecture logicielle ?",
      "answer": "Éco-conception logicielle : 1) Optimisation algorithmes (complexité réduite), 2) Lazy loading et pagination, 3) Cache intelligent pour réduire calculs, 4) Compression données/images, 5) Base de données optimisées (index, requêtes), 6) Architecture serverless/cloud-native, 7) Monitoring consommation énergétique, 8) Code quality (moins de bugs = moins de ressources), 9) Lifecycle management données, 10) Green hosting providers. Mesurer impact carbone, optimiser performance = écologie."
    }
  ],
  "tests": [
    {
      "question": "Qu'est-ce qu'un plan de tests et pourquoi est-il important ?",
      "answer": "Un plan de tests est un document détaillant la stratégie, l'approche, les ressources et le calendrier des activités de test. Il contient : objectifs, périmètre, types de tests, environnements, critères d'entrée/sortie, risques, planning. Importance : 1) Assure la couverture complète des fonctionnalités, 2) Optimise les ressources et le temps, 3) Définit les responsabilités, 4) Facilite la communication équipe, 5) Permet le suivi de la qualité, 6) Réduit les risques de régression, 7) Standardise les processus."
    },
    {
      "question": "Quels sont les types de tests inclus dans un plan de tests ?",
      "answer": "Types de tests dans un plan : 1) Tests fonctionnels : unitaires, intégration, système, acceptation, 2) Tests non-fonctionnels : performance, charge, stress, sécurité, compatibilité, 3) Tests structurels : boîte blanche, couverture de code, 4) Tests de changement : régression, confirmation, 5) Tests spécialisés : accessibilité, utilisabilité, installation, 6) Tests automatisés vs manuels. Chaque type répond à des objectifs spécifiques et couvre différents aspects de la qualité logicielle."
    },
    {
      "question": "Quelle est la différence entre un test unitaire et un test d'intégration ?",
      "answer": "Test unitaire : teste une unité de code isolée (fonction, méthode, classe) avec des dépendances mockées. Caractéristiques : rapide, déterministe, nombreux, scope limité. Exemple : tester une fonction de calcul. Test d'intégration : teste l'interaction entre plusieurs composants ou modules. Types : intégration de composants, systèmes, APIs. Plus lents mais vérifient les contrats entre modules. Pyramide des tests : nombreux tests unitaires → quelques tests intégration → peu de tests E2E."
    },
    {
      "question": "Quelle est la différence entre un test manuel et un test automatisé ?",
      "answer": "Test manuel : exécuté par un humain, interaction directe avec l'application, détecte problèmes UX/UI, créativité dans les scénarios, coûteux en temps. Adapté pour : tests exploratoires, utilisabilité, acceptation utilisateur. Test automatisé : exécuté par des scripts/outils, répétable, rapide, intégrable CI/CD, ROI élevé à long terme. Adapté pour : régression, performance, tests répétitifs. Stratégie hybride recommandée : automatiser les cas standards, garder manuel pour l'exploration et validation UX."
    },
    {
      "question": "Quelle est la différence entre tests unitaires, d'intégration, fonctionnels et E2E ?",
      "answer": "Tests unitaires : unité de code isolée, rapides, nombreux. Tests d'intégration : interaction entre composants, APIs, DB. Tests fonctionnels : validation des exigences métier, comportement attendu. Tests E2E : parcours utilisateur complet de bout en bout, interface réelle. Pyramide : beaucoup d'unitaires (base), moins d'intégration/fonctionnels (milieu), peu d'E2E (sommet). Chaque niveau a un coût et une valeur différents. Stratégie équilibrée pour couverture optimale."
    },
    {
      "question": "Qu'est-ce qu'un test de charge ?",
      "answer": "Test de charge : évalue le comportement d'un système sous une charge normale et pic attendue. Objectifs : 1) Identifier les goulots d'étranglement, 2) Valider les temps de réponse, 3) Vérifier la stabilité sous charge, 4) Déterminer la capacité maximale. Types : charge normale, stress (au-delà capacité), spike (pics soudains), volume (gros datasets). Outils : JMeter, LoadRunner, k6, Gatling. Métriques : temps de réponse, throughput, utilisation ressources, taux d'erreur."
    },
    {
      "question": "Pourquoi réaliser des tests unitaires sur un composant métier ?",
      "answer": "Tests unitaires sur composants métier essentiels pour : 1) Validation des règles de gestion complexes, 2) Détection précoce des erreurs logiques, 3) Documentation vivante du comportement attendu, 4) Facilitation des refactors sans crainte, 5) Regression testing automatique, 6) Confiance dans les modifications, 7) Debugging facilité (isolation des problèmes), 8) Respect des spécifications métier. Les composants métier étant le cœur de l'application, leur fiabilité est critique."
    },
    {
      "question": "Qu'est-ce que le Test-Driven Development (TDD) ?",
      "answer": "TDD est une pratique de développement qui suit le cycle Red-Green-Refactor : 1) Red : écrire un test qui échoue pour une fonctionnalité non implémentée, 2) Green : écrire le code minimal pour faire passer le test, 3) Refactor : améliorer le code tout en gardant les tests verts. Avantages : code testé à 100%, design émergent, documentation vivante, confiance dans les refactors, bugs détectés tôt. Discipline requise mais améliore significativement la qualité du code."
    },
    {
      "question": "Quelles sont les bonnes pratiques du Test-Driven Development (TDD) et comment l'implémenter ?",
      "answer": "Bonnes pratiques TDD : 1) Tests simples et focalisés (une assertion par test), 2) Noms de tests explicites et métier, 3) Arrange-Act-Assert structure, 4) Red-Green-Refactor strict (ne pas sauter d'étapes), 5) Refactor tests ET code, 6) Tests indépendants (pas d'ordre d'exécution), 7) Mock les dépendances externes. Implémentation : outils (JUnit, Jest), IDE supportant TDD, pratique en pair programming, formation équipe, adoption progressive sur nouveaux composants."
    },
    {
      "question": "Qu'est-ce que le mocking et comment gérer les dépendances dans les tests ?",
      "answer": "Le mocking consiste à remplacer les dépendances externes par des objets simulés (mocks) pour isoler l'unité testée. Types : Mock (vérification comportement), Stub (retourne des données prédéfinies), Spy (observateur), Fake (implémentation simplifiée). Gestion dépendances : 1) Injection de dépendances, 2) Mocking des APIs/DB, 3) Frameworks : Mockito (Java), Sinon (JS), 4) Test doubles pour services externes, 5) Fixtures pour données test. Objectif : tests rapides, déterministes, isolés."
    },
    {
      "question": "Comment créer un environnement de test ?",
      "answer": "Création environnement test : 1) Isolation (base de données test séparée), 2) Données de test reproductibles (fixtures, factories), 3) Configuration spécifique (properties/env vars), 4) Dépendances mockées/stubbed, 5) Nettoyage automatique après tests, 6) Parallélisation possible, 7) CI/CD integration, 8) Docker pour reproductibilité. Stratégies : base in-memory (H2), TestContainers, environnements éphémères cloud. Principe : tests doivent être indépendants et répétables."
    },
    {
      "question": "Que faire si un test échoue ?",
      "answer": "Quand un test échoue : 1) Analyser le message d'erreur précisément, 2) Reproduire l'échec localement, 3) Vérifier si c'est un vrai bug ou test défaillant, 4) Debugger avec breakpoints/logs, 5) Corriger le code ou ajuster le test, 6) Relancer tous les tests impactés, 7) Documenter la cause si complexe, 8) Ne jamais ignorer/commenter un test qui échoue. En CI : bloquer le merge/déploiement, notifier l'équipe, analyser les logs de build."
    },
    {
      "question": "Quels outils et frameworks recommandes-tu pour automatiser les tests ?",
      "answer": "Outils tests par type : Unitaires : JUnit (Java), Jest (JS), pytest (Python), xUnit (.NET). Intégration : TestNG, Mockito, WireMock. E2E : Selenium, Cypress, Playwright, Puppeteer. Performance : JMeter, k6, Gatling. API : Rest Assured, Postman/Newman, Insomnia. Mobile : Appium, Espresso, XCTest. CI/CD : intégration native Jenkins/GitHub Actions. Runners : Maven Surefire, npm test. Choix selon : langage, type app, équipe skills, écosystème existant."
    },
    {
      "question": "Comment organiser et prioriser les tests en méthodologie Agile ?",
      "answer": "Organisation tests Agile : 1) Pyramide des tests (beaucoup unitaires, moins E2E), 2) Tests dans Definition of Done, 3) Acceptance criteria = scenarios de test, 4) Test automation dans sprints, 5) Régression automatisée continue. Priorisation : 1) Fonctionnalités critiques d'abord, 2) Risques métier élevés, 3) Zones de code instables, 4) User stories prioritaires. Pratiques : BDD (Behavior Driven Development), ATDD (Acceptance Test Driven Development), tests exploratoires en fin de sprint."
    }
  ],
  "security": [
    {
      "question": "Pourquoi utiliser HTTPS au lieu de HTTP ?",
      "answer": "HTTPS (HTTP + SSL/TLS) apporte : 1) Chiffrement des données en transit, protection contre l'écoute, 2) Authentification du serveur via certificats, 3) Intégrité des données, détection des modifications, 4) Confiance utilisateur (cadenas vert), 5) SEO amélioré (Google favorise HTTPS), 6) APIs modernes l'exigent (geolocation, camera), 7) Conformité réglementaire (RGPD), 8) Protection contre man-in-the-middle attacks. HTTP est obsolète et non sécurisé pour les données sensibles."
    },
    {
      "question": "Pourquoi ne jamais stocker un mot de passe en clair et comment le sécuriser ?",
      "answer": "Risques du stockage en clair : vol de base de données expose tous les mots de passe, non-conformité RGPD, responsabilité légale. Sécurisation : 1) Hachage avec sel (bcrypt, Argon2, scrypt), 2) Coût computationnel élevé contre bruteforce, 3) Sel unique par mot de passe, 4) Politique de mots de passe forts, 5) Authentification multi-facteurs (2FA), 6) Rotation régulière, 7) Détection de fuites (Have I Been Pwned), 8) Chiffrement de la base de données."
    },
    {
      "question": "Quelles sont les bonnes pratiques pour définir un mot de passe sécurisé ?",
      "answer": "Mot de passe sécurisé : 1) Longueur minimale 12-16 caractères, 2) Mélange majuscules, minuscules, chiffres, symboles, 3) Éviter informations personnelles et mots du dictionnaire, 4) Unique par service, 5) Passphrase mémorable avec mots aléatoires, 6) Gestionnaire de mots de passe recommandé, 7) Vérification force en temps réel, 8) Pas de stockage en clair, 9) Expiration périodique pour comptes sensibles, 10) Formation utilisateurs sensibilisation sécurité."
    },
    {
      "question": "Comment intégrer la cryptographie et la gestion des identités dans une application sécurisée ?",
      "answer": "Intégration crypto et identités : 1) PKI (Public Key Infrastructure) pour certificats, 2) HSM (Hardware Security Module) pour clés sensibles, 3) Chiffrement asymétrique pour échange clés, 4) Chiffrement symétrique pour données, 5) Signatures numériques pour intégrité, 6) SSO/SAML/OAuth2 pour fédération identités, 7) LDAP/Active Directory pour annuaires, 8) MFA obligatoire, 9) Rotation automatique des clés, 10) Audit trails chiffrés, 11) Vault pour secrets management."
    },
    {
      "question": "Comment implémenter un système de gestion des permissions efficace ?",
      "answer": "Système permissions efficace : 1) RBAC (Role-Based Access Control) avec rôles métier, 2) ABAC (Attribute-Based) pour règles complexes, 3) Principe moindre privilège par défaut, 4) Héritage hiérarchique des permissions, 5) Permissions granulaires (CRUD par ressource), 6) Délégation contrôlée de permissions, 7) Audit et révision régulière, 8) Interface admin intuitive, 9) Tests automatisés des autorisations, 10) Documentation des rôles/permissions, 11) Workflow d'approbation pour changements sensibles."
    },
    {
      "question": "Quelles sont les meilleures pratiques pour sécuriser les données sensibles en transit et au repos ?",
      "answer": "Données en transit : 1) TLS 1.3 minimum, 2) Certificate pinning, 3) VPN pour réseaux non sûrs, 4) API Gateway avec chiffrement bout-en-bout. Données au repos : 1) Chiffrement filesystem (BitLocker, FileVault), 2) Chiffrement base de données (TDE), 3) Clés de chiffrement séparées des données, 4) Backup chiffrées, 5) Destruction sécurisée, 6) Classification des données (public, confidentiel, secret), 7) Access control granulaire, 8) Audit des accès, 9) Tokenization pour données sensibles."
    },
    {
      "question": "Quels sont les défis spécifiques à la sécurité des applications mobiles et PWA ?",
      "answer": "Défis mobiles/PWA : 1) Stockage local non sécurisé (keychain, encrypted preferences), 2) Communication réseau sur WiFi publics, 3) Jailbreak/Root detection, 4) Reverse engineering apps, 5) Certificate pinning contournement, 6) Biométrie et authentification locale, 7) Updates sécurité fragmentées, 8) Permissions excessives, 9) Code obfuscation nécessaire, 10) Service Workers et cache PWA, 11) APIs sensibles du navigateur, 12) CSP (Content Security Policy) strict, 13) Tests sur devices physiques multiples."
    },
    {
      "question": "Comment détecter et corriger les failles de sécurité dans une application en production ?",
      "answer": "Détection failles production : 1) SIEM (Security Information Event Management), 2) WAF (Web Application Firewall) avec logs, 3) Monitoring anomalies comportementales, 4) Vulnerability scanning automatisé, 5) Bug bounty programs, 6) Pentest réguliers, 7) Code review sécurité, 8) Dependency checking (Snyk, OWASP Dependency Check). Correction : 1) Incident response plan, 2) Patch management rapide, 3) Rollback procédures, 4) Communication transparent, 5) Post-mortem et amélioration continue, 6) Monitoring renforcé post-correction."
    },
    {
      "question": "Quel est le rôle de l'ANSSI et pourquoi suivre ses recommandations ?",
      "answer": "L'ANSSI (Agence Nationale de la Sécurité des Systèmes d'Information) est l'autorité française de cybersécurité. Rôles : 1) Protection des systèmes d'information de l'État, 2) Réglementation et certification sécurité, 3) Veille sur les menaces cyber, 4) Accompagnement des organismes publics et privés, 5) Incident response national. Suivre ses recommandations : conformité réglementaire, bonnes pratiques éprouvées, protection contre menaces actuelles, crédibilité auprès des clients/partenaires, éviter sanctions."
    },
    {
      "question": "Quelles sont les obligations du RGPD pour une application qui stocke des données utilisateurs ?",
      "answer": "Obligations RGPD : 1) Consentement explicite et révocable, 2) Finalité définie et proportionnelle, 3) Durée de conservation limitée, 4) Droit d'accès, rectification, effacement ('droit à l'oubli'), 5) Portabilité des données, 6) Notification violation sous 72h, 7) DPO si traitement à grande échelle, 8) Analyse d'impact (DPIA) si risque élevé, 9) Privacy by design, 10) Registre des traitements, 11) Amendes jusqu'à 4% du CA mondial. Documentation et preuves de conformité essentielles."
    },
    {
      "question": "Quelles obligations le RGPD impose-t-il pour une interface utilisateur ?",
      "answer": "RGPD pour interfaces : 1) Consentement granulaire par finalité (cookies, analytics, marketing), 2) Interfaces de gestion du consentement claires, 3) Information transparente sur collecte/usage, 4) Accès facilité aux paramètres de confidentialité, 5) Export/suppression données en self-service, 6) Formulaires avec finalités explicites, 7) Opt-in par défaut (pas de cases pré-cochées), 8) Bannières cookies conformes, 9) Langue locale et compréhensible, 10) Design patterns respectueux (dark patterns interdits), 11) Accessibilité des fonctions RGPD."
    },
    {
      "question": "Quelles obligations légales dois-tu respecter lors de la conception d'une interface ?",
      "answer": "Obligations légales interfaces : 1) RGPD (protection données personnelles), 2) Accessibilité numérique (RGAA en France, WCAG internationalement), 3) Mentions légales obligatoires, 4) CGU/CGV conformes, 5) Cookies et traceurs (consentement CNIL), 6) Droit à l'oubli implémenté, 7) Sécurité des mineurs, 8) Anti-discrimination (conception inclusive), 9) Propriété intellectuelle respectée, 10) E-commerce : informations obligatoires, délai rétractation, 11) Hébergement : identification hébergeur, 12) Archivage légal selon secteur d'activité."
    }
  ],
  "design": [
    {
      "question": "Pourquoi réaliser des maquettes avant de coder ?",
      "answer": "Réaliser des maquettes avant le développement : 1) Valide l'idée avec les parties prenantes tôt, 2) Détecte les problèmes UX avant le code, 3) Facilite la communication équipe/client, 4) Estime mieux les coûts et délais, 5) Guide le développement avec une vision claire, 6) Permet les itérations rapides et peu coûteuses, 7) Évite les malentendus et refonte, 8) Teste l'utilisabilité en amont, 9) Optimise l'architecture technique. Coût minime vs bénéfices énormes."
    },
    {
      "question": "Quelle est la différence entre un wireframe et une maquette ?",
      "answer": "Wireframe : structure schématique en noir et blanc, focus sur layout et hiérarchie de l'information, sans couleurs ni images finales. Objectif : architecture de l'information et navigation. Maquette : design visuel détaillé avec couleurs, typographies, images réelles, représentation fidèle du rendu final. Prototype : maquette interactive avec transitions et comportements. Progression : Wireframe → Maquette → Prototype → Développement. Chaque étape ajoute du détail et valide différents aspects."
    },
    {
      "question": "Quelle est la différence entre une maquette et un prototype ?",
      "answer": "Maquette : représentation visuelle statique haute-fidélité avec design final (couleurs, typographies, images), montre l'apparence exacte. Prototype : version interactive de la maquette avec navigation, transitions, animations, simule le comportement réel. Types de prototypes : 1) Basse fidélité (wireframes cliquables), 2) Haute fidélité (proche du produit final), 3) Fonctionnel (avec vraies données). Outils : Figma, Adobe XD, Principle, Framer. Prototype permet validation UX avant développement."
    },
    {
      "question": "Que contient un dossier de conception ?",
      "answer": "Dossier de conception contient : 1) Brief et cahier des charges, 2) Personas et user journey maps, 3) Benchmarks concurrentiels, 4) Arborescence et architecture information, 5) Wireframes et user flows, 6) Maquettes haute fidélité toutes résolutions, 7) Prototype interactif, 8) Charte graphique et style guide, 9) Spécifications techniques (espacements, couleurs, fonts), 10) Assets exportés (icônes, images), 11) Documentation développeurs, 12) Tests utilisateurs et recommandations."
    },
    {
      "question": "Quels outils de maquettage utiliser et comment les intégrer dans un projet ?",
      "answer": "Outils maquettage : 1) Figma : collaboratif, web-based, components/variants, 2) Adobe XD : écosystème Adobe, prototypage avancé, 3) Sketch : Mac only, plugins riches, 4) Framer : prototypage complexe avec code. Intégration projet : 1) Librairies de composants partagées, 2) Design system synchronisé, 3) Handoff développeurs (inspect mode), 4) Versioning et feedback clients, 5) Export assets automatisé, 6) Specs développeurs générées, 7) Tests utilisateurs sur prototypes, 8) Validation continue design/développement."
    },
    {
      "question": "Quelle est la différence entre UI et UX ?",
      "answer": "UI (User Interface) : aspect visuel et interactif, design des éléments graphiques, couleurs, typographies, boutons, animations. Focus sur l'esthétique et l'utilisabilité immédiate. UX (User Experience) : expérience globale utilisateur, parcours, émotions, efficacité, satisfaction. Inclut recherche utilisateur, architecture de l'information, tests d'utilisabilité. UX = stratégie et recherche, UI = implémentation visuelle. UX définit ce que fait le produit, UI définit comment il apparaît. Collaboration étroite nécessaire."
    },
    {
      "question": "Quels principes ergonomiques faut-il respecter pour une bonne expérience utilisateur ?",
      "answer": "Principes ergonomiques UX : 1) Simplicité et clarté (loi de Hick), 2) Cohérence interface et interactions, 3) Feedback immédiat sur actions, 4) Contrôle utilisateur (undo/redo), 5) Prévention erreurs et récupération, 6) Reconnaissance plutôt que rappel, 7) Flexibilité pour experts/novices, 8) Design esthétique et minimaliste, 9) Aide et documentation accessibles, 10) Navigation intuitive, 11) Hiérarchie visuelle claire, 12) Affordances évidentes, 13) Loi de Fitts (cibles importantes grandes), 14) Gestalt principles."
    },
    {
      "question": "Comment analyser un cahier des charges et formaliser les besoins utilisateurs ?",
      "answer": "Analyse cahier des charges : 1) Extraction objectifs métier et contraintes, 2) Identification personas et contextes usage, 3) Mapping besoins fonctionnels/non-fonctionnels, 4) User stories avec acceptance criteria. Formalisation besoins : 1) Personas détaillées avec jobs-to-be-done, 2) User journey maps avec pain points, 3) Functional requirements documentés, 4) User stories priorisées (MoSCoW), 5) Wireflows et task flows, 6) Matrices de traçabilité, 7) Prototypes validation concept, 8) Tests utilisateurs early feedback. Méthodes : interviews, observations, surveys, card sorting."
    },
    {
      "question": "Quelles sont les normes d'accessibilité à respecter pour concevoir une interface inclusive ?",
      "answer": "Normes d'accessibilité (WCAG 2.1) : 1) Perceptible : alternatives textuelles pour images, contrastes suffisants (4.5:1), texte redimensionnable, 2) Utilisable : navigation au clavier, pas de clignotements, délais suffisants, 3) Compréhensible : texte lisible, navigation prévisible, aide à la saisie, 4) Robuste : compatible avec technologies d'assistance. En France : RGAA (Référentiel Général d'Amélioration de l'Accessibilité). Tests avec lecteurs d'écran, validation HTML, audit accessibilité. Bénéficie à tous les utilisateurs."
    },
    {
      "question": "Quels éléments composent une charte graphique ?",
      "answer": "Charte graphique contient : 1) Logo : versions, variations, utilisation correcte/incorrecte, 2) Couleurs : palette principale/secondaire, codes RGB/CMYK/Pantone, 3) Typographies : familles, hiérarchie, tailles, 4) Iconographie : style, pictogrammes, illustrations, 5) Layouts : grilles, espacements, marges, 6) Photographie : style, traitement, cadrages, 7) Éléments graphiques : motifs, textures, 8) Applications : papeterie, digital, signalétique. Guide l'identité visuelle cohérente sur tous supports."
    }
  ],
  "project": [
    {
      "question": "Comment planifies-tu les tâches de développement d'un projet ?",
      "answer": "Planification développement : 1) Décomposition fonctionnalités en user stories, 2) Estimation effort (story points, planning poker), 3) Priorisation selon valeur métier (MoSCoW), 4) Sprint planning avec capacité équipe, 5) Backlog refinement régulier, 6) Identification dépendances et blocages, 7) Definition of Done claire, 8) Buffer pour imprévus (20%), 9) Roadmap long terme avec milestones, 10) Rétrospectives pour amélioration continue. Outils : Jira, Azure DevOps, Trello, roadmaps visuels."
    },
    {
      "question": "Quelle est la différence entre une gestion de projet séquentielle et Agile ?",
      "answer": "Gestion séquentielle (Waterfall) : phases linéaires (analyse→conception→développement→test→déploiement), planification complète en amont, changements difficiles. Avantages : prévisibilité, documentation complète. Inconvénients : rigidité, feedback tardif, risque d'inadéquation. Agile : itérations courtes (sprints), adaptabilité aux changements, collaboration client continue, livraisons fréquentes. Avantages : flexibilité, feedback rapide, valeur métier continue. Choix selon : complexité projet, stabilité exigences, équipe."
    },
    {
      "question": "Quelle est la différence entre une approche séquentielle et Agile en gestion de projet ?",
      "answer": "Approche séquentielle : 1) Phases successives avec gates, 2) Planification détaillée initiale, 3) Changements coûteux, 4) Validation finale, 5) Documentation extensive, 6) Équipes spécialisées par phase. Agile : 1) Itérations courtes et adaptatives, 2) Planification émergente, 3) Changements encouragés, 4) Feedback continu, 5) Documentation juste suffisante, 6) Équipes cross-fonctionnelles. Hybride possible : phases macro avec sprints internes, SAFe pour grandes organisations."
    },
    {
      "question": "Qu'est-ce qu'un daily meeting en Agile ?",
      "answer": "Daily meeting (stand-up) : réunion quotidienne de 15 minutes max avec l'équipe de développement. 3 questions par membre : 1) Qu'ai-je fait hier ? 2) Que vais-je faire aujourd'hui ? 3) Quels obstacles rencontré-je ? Objectifs : synchronisation équipe, identification des blocages, ajustement quotidien, amélioration collaboration. Règles : debout pour la brièveté, même heure/lieu, focus sur les tâches pas les détails techniques, résolution problèmes après la réunion. Facilite la transparence et l'entraide."
    },
    {
      "question": "Quels outils peux-tu utiliser pour gérer un projet en équipe ?",
      "answer": "Outils gestion projet : 1) Planification : Jira, Asana, Trello, Monday.com, 2) Communication : Slack, Microsoft Teams, Discord, 3) Versioning : Git (GitHub, GitLab, Bitbucket), 4) Documentation : Confluence, Notion, Wiki, 5) Design : Figma, Adobe XD, 6) CI/CD : Jenkins, GitHub Actions, 7) Monitoring : New Relic, Datadog, 8) Files : Google Drive, SharePoint, 9) Temps : Toggl, Harvest. Choix selon taille équipe, budget, intégrations nécessaires. Important : éviter la sur-outillage."
    },
    {
      "question": "Quels sont les principaux outils de gestion de projet informatique ?",
      "answer": "Outils gestion projet IT : 1) Planification : Microsoft Project, Smartsheet pour Gantt complexes, 2) Agile : Jira, Azure DevOps, Rally, VersionOne, 3) Collaboration : Confluence, SharePoint, Notion, 4) Communication : Slack, Teams, Mattermost, 5) Temps/Budget : Toggl, Harvest, Clockify, 6) Ressources : Resource Guru, Float, 7) Risques : Risk Register, Monte Carlo simulations, 8) Portfolio : Clarity, ServiceNow PPM. Intégration ecosystem crucial pour efficacité."
    },
    {
      "question": "Comment organiser et animer une réunion efficace dans un projet informatique ?",
      "answer": "Réunion efficace : Avant : 1) Objectif clair et agenda partagé, 2) Participants pertinents uniquement, 3) Durée limitée (25/50min), 4) Documentation préparatoire. Pendant : 1) Timeboxing strict, 2) Facilitateur neutre, 3) Parking lot pour hors-sujet, 4) Actions/décisions notées. Après : 1) Compte-rendu avec actions/responsables/deadlines, 2) Suivi dans outils projet, 3) Feedback réunion. Types spécialisés : sprint planning, retrospective, demo, architecture decision records. Remote : outils collaboratifs, caméras obligatoires."
    },
    {
      "question": "Comment assurer la qualité du code dans un projet ?",
      "answer": "Qualité code : 1) Standards de codage et conventions équipe, 2) Code reviews systématiques (pull requests), 3) Tests automatisés (unitaires, intégration, E2E), 4) Analyse statique de code (SonarQube, ESLint), 5) CI/CD avec gates qualité, 6) Pair programming ou mob programming, 7) Refactoring régulier, 8) Documentation technique à jour, 9) Formation continue équipe, 10) Métriques qualité (couverture tests, complexité cyclomatique). Culture qualité plus importante que les outils."
    },
    {
      "question": "Pourquoi est-il important de rédiger de la documentation technique dans un projet ?",
      "answer": "Documentation technique essentielle pour : 1) Onboarding nouveaux développeurs, 2) Maintenance et évolution future, 3) Partage connaissance (pas de single point of failure), 4) Décisions d'architecture justifiées, 5) Compliance et audit, 6) Debugging facilité, 7) APIs utilisables par autres équipes, 8) Handover projets, 9) Formation utilisateurs. Types : README, API docs, architecture decisions (ADR), runbooks, troubleshooting guides. Outils : GitBook, Confluence, Docusaurus. Maintenir à jour crucial."
    },
    {
      "question": "Quelle est la différence entre un use case et une user story ?",
      "answer": "Use case : description détaillée d'une interaction utilisateur-système pour atteindre un objectif, format structuré avec acteurs, préconditions, scénarios principaux/alternatifs, postconditions. Focus technique et exhaustif. User story : description simple d'une fonctionnalité du point de vue utilisateur, format : 'En tant que [qui], je veux [quoi] afin de [pourquoi]'. Focus valeur métier et conversation. Use case = spécification détaillée, User story = besoin à développer. User stories sont décomposées en tâches techniques."
    }
  ],
  "tools": [
    {
      "question": "Quels sont les outils indispensables à ton environnement de développement ?",
      "answer": "Outils indispensables : 1) IDE/Éditeur : VS Code, IntelliJ, Eclipse avec extensions, 2) Versioning : Git + GitHub/GitLab, 3) Terminal/Shell : PowerShell, Bash, Zsh, 4) Navigateur avec dev tools, 5) Gestionnaire de paquets : npm, Maven, Composer, 6) Base de données : MySQL Workbench, pgAdmin, 7) API testing : Postman, Insomnia, 8) Docker pour conteneurisation, 9) Linter/Formatter pour la qualité code, 10) Debugger intégré, 11) Documentation : notes, wiki. Configuration synchronisée via dotfiles."
    },
    {
      "question": "Pourquoi utiliser un gestionnaire de versions comme Git ?",
      "answer": "Git apporte : 1) Historique complet des modifications avec possibilité de revenir en arrière, 2) Collaboration équipe sans conflits via branches et merge, 3) Sauvegarde distribuée (chaque clone = backup complet), 4) Branches pour développement parallèle de fonctionnalités, 5) Tags pour marquer les versions, 6) Audit trail pour traçabilité, 7) Integration CI/CD, 8) Workflows de développement (GitFlow, GitHub Flow), 9) Code reviews via pull requests, 10) Résolution intelligente des conflits. Indispensable pour tout projet sérieux."
    },
    {
      "question": "Comment assures-tu la compatibilité entre ton environnement local et l'environnement de production ?",
      "answer": "Compatibilité dev/prod : 1) Docker pour containerisation identique, 2) Variables d'environnement pour configuration, 3) Infrastructure as Code (Terraform, Ansible), 4) Même versions des dépendances (package-lock.json), 5) Tests dans environnements staging identiques à la prod, 6) CI/CD pipeline pour déploiements cohérents, 7) Configuration externalisée, 8) Monitoring et logs comparables, 9) Feature flags pour rollout progressif, 10) Documentation environnements. Principe : 'Dev/Prod Parity' des 12-factor apps."
    }
  ]
}
