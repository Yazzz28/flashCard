{
    "CDA": {
        "frontend": [
            {
                "question": "Qu'est-ce qu'une SPA ?",
                "answer": "Une SPA (Single Page Application) est une application web qui charge une seule page HTML et met à jour dynamiquement le contenu en fonction des interactions de l'utilisateur, sans recharger la page entière. Les SPAs utilisent JavaScript pour manipuler le DOM et communiquent avec le serveur via des APIs pour récupérer ou envoyer des données. Avantages : performance améliorée, expérience utilisateur fluide. Inconvénients : SEO plus complexe, temps de chargement initial plus long."
            },
            {
                "question": "Qu'est-ce qu'Angular ?",
                "answer": "Angular est un framework JavaScript open-source développé par Google pour créer des applications web dynamiques et des SPAs. Il utilise TypeScript par défaut, suit une architecture basée sur des composants, et propose des fonctionnalités comme le data binding bidirectionnel, l'injection de dépendances, le routing, et les directives. Angular facilite le développement d'applications complexes avec une structure organisée et maintenable."
            },
            {
                "question": "Quels sont les avantages d'un framework orienté composant comme Angular ?",
                "answer": "Les avantages incluent : la réutilisabilité des composants dans différentes parties de l'application, une meilleure organisation du code en modules logiques, la facilité de maintenance et de test des composants isolés, l'encapsulation qui évite les conflits entre composants, la possibilité de développer en équipe avec des responsabilités claires par composant, et la scalabilité pour les grandes applications."
            },
            {
                "question": "Quels sont les prérequis pour installer et exécuter un projet Angular ?",
                "answer": "Les prérequis sont : Node.js (version LTS recommandée) avec npm ou yarn comme gestionnaire de paquets, Angular CLI installé globalement (npm install -g @angular/cli), un éditeur de code (VS Code recommandé), et optionnellement Git pour le versioning. Pour créer un projet : ng new mon-projet, puis ng serve pour le lancer en mode développement."
            },
            {
                "question": "Comment gères-tu un événement utilisateur dans Angular ?",
                "answer": "Dans Angular, on gère les événements avec l'event binding en utilisant des parenthèses : (click)='maMethode()', (submit)='onSubmit()', (change)='onChange($event)'. On peut accéder à l'objet event avec $event. Dans le composant TypeScript, on définit les méthodes correspondantes. Exemple : <button (click)='onClick()'>Click me</button> et dans le composant : onClick() { console.log('Bouton cliqué'); }"
            },
            {
                "question": "Comment récupères-tu des données d'une API dans une interface Angular ?",
                "answer": "On utilise le service HttpClient d'Angular : 1) Importer HttpClientModule dans app.module.ts, 2) Injecter HttpClient dans le service ou composant, 3) Utiliser les méthodes HTTP (get, post, put, delete) qui retournent des Observables, 4) S'abonner aux Observables avec subscribe() ou utiliser async pipe dans le template. Exemple : this.http.get<User[]>('/api/users').subscribe(users => this.users = users);"
            },
            {
                "question": "Comment sécuriser les pages en Angular selon le rôle de l'utilisateur ?",
                "answer": "On utilise les Guards d'Angular : 1) CanActivate pour protéger l'accès aux routes, 2) Créer un AuthGuard qui vérifie l'authentification et les rôles, 3) Implémenter la méthode canActivate() qui retourne true/false, 4) Ajouter le guard dans les routes : { path: 'admin', component: AdminComponent, canActivate: [AuthGuard] }, 5) Vérifier les tokens JWT et rôles côté serveur également."
            },
            {
                "question": "Comment rends-tu une interface responsive ?",
                "answer": "Pour rendre une interface responsive : 1) Utiliser CSS Grid et Flexbox pour des layouts adaptatifs, 2) Définir des media queries pour différentes tailles d'écran, 3) Utiliser des unités relatives (%, em, rem, vw, vh), 4) Adopter l'approche mobile-first, 5) Utiliser des frameworks CSS comme Bootstrap ou Tailwind, 6) Tester sur différents appareils et tailles d'écran, 7) Optimiser les images avec srcset et picture."
            },
            {
                "question": "Pourquoi est-il important d'adapter une interface à différents types de supports ?",
                "answer": "C'est important car : 1) Plus de 50% du trafic web vient du mobile, 2) Google privilégie les sites mobile-friendly dans son référencement, 3) L'expérience utilisateur varie selon l'appareil utilisé, 4) Cela améliore l'accessibilité pour tous les utilisateurs, 5) Cela augmente le taux de conversion et réduit le taux de rebond, 6) C'est une exigence professionnelle moderne."
            },
            {
                "question": "Comment t'assures-tu que ton interface respecte la maquette du dossier de conception ?",
                "answer": "Pour respecter la maquette : 1) Comparaison pixel-perfect avec des outils de superposition, 2) Utilisation d'un design system cohérent, 3) Respect des spacing, couleurs et typographies définies, 4) Tests sur différents navigateurs et appareils, 5) Validation avec l'équipe design, 6) Utilisation d'outils comme Figma inspect ou Zeplin, 7) Documentation des écarts justifiés, 8) Tests d'intégration réguliers pendant le développement."
            },
            {
                "question": "Pourquoi et comment tester une interface utilisateur ?",
                "answer": "Tests UI essentiels pour : 1) Validation fonctionnelle des interactions, 2) Détection de régressions visuelles, 3) Vérification de l'accessibilité, 4) Performance et responsive design. Comment : Tests automatisés (Selenium, Cypress, Playwright), tests manuels, tests d'utilisabilité, tests de compatibilité navigateurs, tests de performance (Lighthouse), validation W3C, tests d'accessibilité (axe, Wave). Combine approches pour couverture complète."
            },
            {
                "question": "Quels mécanismes peux-tu mettre en place pour sécuriser une interface ?",
                "answer": "Sécurisation interface : 1) Validation côté client ET serveur, 2) Échappement des données utilisateur, 3) CSP (Content Security Policy) headers, 4) HTTPS obligatoire, 5) Protection CSRF avec tokens, 6) Sanitization des entrées, 7) Rate limiting, 8) Authentification et autorisation, 9) Audit sécurité régulier, 10) Mise à jour des dépendances, 11) CORS configuré correctement, 12) Headers sécurisés (X-Frame-Options, X-XSS-Protection)."
            },
            {
                "question": "Comment fonctionne le DOM et quelle est son importance dans les interfaces web ?",
                "answer": "Le DOM (Document Object Model) est une représentation en arbre des éléments HTML d'une page web. Chaque balise devient un nœud que JavaScript peut manipuler dynamiquement. Son importance : 1) Permet l'interactivité via JavaScript, 2) Structure hiérarchique des éléments, 3) Interface entre HTML/CSS et JavaScript, 4) Permet la manipulation en temps réel du contenu, 5) Base pour les frameworks modernes, 6) Gestion des événements utilisateur."
            },
            {
                "question": "Quelles sont les principales vulnérabilités web (XSS, CSRF) et comment s'en prémunir ?",
                "answer": "XSS (Cross-Site Scripting) : injection de scripts malveillants. Prévention : validation et échappement des données, CSP headers. CSRF (Cross-Site Request Forgery) : exécution d'actions non autorisées. Prévention : tokens CSRF, vérification de l'origine, SameSite cookies. Autres vulnérabilités : injection SQL (requêtes préparées), clickjacking (X-Frame-Options), HTTPS obligatoire, validation côté serveur."
            },
            {
                "question": "Comment se protéger contre les injections SQL, XSS et CSRF ?",
                "answer": "Protection multicouche : SQL Injection : requêtes préparées, ORM, validation stricte, principe moindre privilège DB. XSS : échappement HTML, CSP, validation entrées, sanitization. CSRF : tokens synchronisés, SameSite cookies, vérification Referer/Origin. Général : validation côté serveur obligatoire, encodage approprié, framework sécurisé, tests sécurité, monitoring, formation équipe. Never trust user input !"
            },
            {
                "question": "Pourquoi doit-on valider les données côté frontend et backend ?",
                "answer": "Double validation nécessaire : Frontend : UX améliorée, feedback immédiat, réduction requêtes serveur, guide utilisateur. Backend : sécurité réelle (frontend contournable), intégrité données, conformité business rules, protection API. Frontend = confort utilisateur, Backend = sécurité obligatoire. Les validations frontend peuvent être désactivées/modifiées, donc backend reste la barrière de sécurité principale. Principe : never trust client-side data."
            },
            {
                "question": "Quelles sont les bonnes pratiques UX pour améliorer l'ergonomie d'une interface web ?",
                "answer": "Bonnes pratiques UX : 1) Design intuitif et prévisible, 2) Navigation claire et cohérente, 3) Feedback visuel immédiat, 4) Chargement rapide (<3s), 5) Mobile-first design, 6) Accessibilité universelle, 7) Contenu scannable, 8) CTAs clairs, 9) Formulaires simples, 10) Tests utilisateurs réguliers, 11) Hiérarchie visuelle claire, 12) Erreurs explicites et solutions, 13) Recherche efficace, 14) Personnalisation adaptée."
            },
            {
                "question": "Quels facteurs influencent le référencement SEO d'une interface web ?",
                "answer": "Facteurs SEO : 1) Performance (Core Web Vitals), 2) Mobile-friendly responsive, 3) Structure HTML sémantique, 4) Balises meta optimisées, 5) Contenu de qualité et unique, 6) URL structure claire, 7) Images optimisées avec alt, 8) HTTPS obligatoire, 9) Schema markup, 10) Sitemap XML, 11) Linking interne/externe, 12) Temps de chargement, 13) Accessibilité, 14) Contenu frais régulier, 15) Social signals."
            },
            {
                "question": "Quelles règles d'accessibilité dois-tu respecter lors du développement d'une interface ?",
                "answer": "Règles d'accessibilité WCAG 2.1 : 1) Perceptible : alt text images, contrastes 4.5:1, sous-titres vidéos, 2) Utilisable : navigation clavier, pas de clignotements, temps suffisant, 3) Compréhensible : langage simple, navigation prévisible, aide erreurs, 4) Robuste : HTML valide, compatible assistive technologies. Tests : lecteurs d'écran, validation automatique, audit manuel. Bénéficie à tous les utilisateurs."
            },
            {
                "question": "Comment améliorer l'accessibilité d'une interface ?",
                "answer": "Amélioration accessibilité : 1) HTML sémantique correct, 2) Alternative text pour images, 3) Contrastes suffisants, 4) Navigation clavier fluide, 5) Labels explicites formulaires, 6) ARIA labels appropriés, 7) Focus visible, 8) Tailles cliquables ≥44px, 9) Tests lecteurs d'écran, 10) Vidéos sous-titrées, 11) Structure hiérarchique headings, 12) Messages d'erreur clairs, 13) Temps de session adaptés, 14) Documentation utilisateur."
            },
            {
                "question": "Qu'est-ce que le RGAA et pourquoi est-il important ?",
                "answer": "RGAA (Référentiel Général d'Amélioration de l'Accessibilité) : standard français d'accessibilité numérique basé sur WCAG. Obligatoire pour services publics, recommandé pour privé. Importance : 1) Conformité légale, 2) Inclusion universelle, 3) Amélioration UX globale, 4) SEO renforcé, 5) Image de marque, 6) Marché élargi (12M personnes handicapées France). Certification possible, audits réguliers nécessaires."
            }
        ],
        "backend": [
            {
                "question": "Quels sont les principes SOLID en programmation orientée objet ?",
                "answer": "SOLID est un acronyme de 5 principes : S - Single Responsibility Principle : une classe ne doit avoir qu'une seule responsabilité. O - Open/Closed Principle : ouvert à l'extension, fermé à la modification. L - Liskov Substitution Principle : les objets dérivés doivent pouvoir remplacer leurs objets de base. I - Interface Segregation Principle : préférer plusieurs interfaces spécifiques à une interface générale. D - Dependency Inversion Principle : dépendre d'abstractions, pas de concretions."
            },
            {
                "question": "Quels sont les quatre piliers de la Programmation Orientée Objet (POO) ?",
                "answer": "Les 4 piliers sont : 1) Encapsulation : regrouper données et méthodes dans une classe, contrôler l'accès via les modificateurs (private, protected, public). 2) Héritage : créer de nouvelles classes basées sur des classes existantes, réutiliser et étendre le code. 3) Polymorphisme : capacité d'un objet à prendre plusieurs formes, méthodes ayant le même nom mais comportements différents. 4) Abstraction : masquer la complexité d'implémentation, exposer seulement l'interface nécessaire."
            },
            {
                "question": "Comment fonctionne le polymorphisme en Java ?",
                "answer": "Le polymorphisme en Java permet qu'un même nom de méthode ait différents comportements selon le type d'objet. Il existe deux types : 1) Polymorphisme de compilation (surcharge) : plusieurs méthodes avec le même nom mais paramètres différents. 2) Polymorphisme d'exécution (redéfinition) : une méthode de classe parent redéfinie dans la classe enfant. Java utilise la résolution dynamique des méthodes (late binding) pour déterminer quelle méthode appeler à l'exécution."
            },
            {
                "question": "Pourquoi utilise-t-on des interfaces en POO ?",
                "answer": "Les interfaces servent à : 1) Définir un contrat que les classes doivent respecter, 2) Permettre l'héritage multiple en Java, 3) Faciliter les tests avec des mocks, 4) Découpler le code et améliorer la flexibilité, 5) Respecter le principe d'inversion de dépendance, 6) Permettre le polymorphisme, 7) Standardiser les comportements entre différentes implémentations, 8) Faciliter la maintenance et l'évolutivité du code."
            },
            {
                "question": "Dans quel cas utiliser une classe abstraite plutôt qu'une interface ?",
                "answer": "Utiliser une classe abstraite quand : 1) Partage de code commun entre classes dérivées, 2) Constructeurs avec logique d'initialisation, 3) Variables d'instance partagées, 4) Méthodes avec implémentation par défaut, 5) Contrôle d'accès varié (protected, private), 6) Évolution future sans casser les implémentations. Interface quand : contrat pur, héritage multiple nécessaire, pas de logique partagée. Règle : classe abstraite = relation 'IS-A' forte, interface = capacité 'CAN-DO'."
            },
            {
                "question": "Pourquoi dit-on que l'héritage favorise la réutilisation du code ?",
                "answer": "L'héritage favorise la réutilisation car : 1) Évite la duplication en héritant des méthodes/attributs de la classe parent, 2) Permet l'extension de fonctionnalités existantes, 3) Factorisation du code commun dans la classe de base, 4) Maintenance centralisée des fonctionnalités communes, 5) Respect du principe DRY (Don't Repeat Yourself), 6) Hiérarchie logique des concepts métier. Attention : privilégier composition over inheritance pour éviter couplage fort."
            },
            {
                "question": "Comment empêcher une classe d'être héritée en Java ?",
                "answer": "En Java, utiliser le mot-clé 'final' devant la déclaration de classe : 'public final class MaClasse'. Exemples : String, Integer, Boolean sont des classes final. Pourquoi : 1) Sécurité et intégrité du design, 2) Performance (pas de virtual method calls), 3) Immutabilité garantie, 4) API stable et prévisible. Alternative : constructeur privé avec factory methods pour contrôler l'instanciation sans empêcher l'héritage."
            },
            {
                "question": "Comment garantit-on l'encapsulation des données en Java ?",
                "answer": "Encapsulation en Java : 1) Attributs privés (private), 2) Getters/setters publics pour accès contrôlé, 3) Validation dans les setters, 4) Retour de copies défensives pour objets mutables, 5) Classes internes privées, 6) Package-private quand approprié. Exemple : private String nom; public String getNom() { return nom; } public void setNom(String nom) { if(nom != null) this.nom = nom; }. Protège l'intégrité des données et cache l'implémentation."
            },
            {
                "question": "Une classe peut-elle implémenter plusieurs interfaces en Java ?",
                "answer": "Oui, une classe Java peut implémenter plusieurs interfaces : 'class MaClasse implements Interface1, Interface2, Interface3'. Avantages : 1) Héritage multiple de comportements, 2) Flexibilité architectural, 3) Respect du contrat de plusieurs APIs, 4) Polymorphisme multiple. Attention aux : conflits de méthodes par défaut (résolution explicite requise), complexité accrue. Exemple : class Voiture implements Vehicule, Assurable, Trackable."
            },
            {
                "question": "Pourquoi et comment appliquer le principe de l'encapsulation ?",
                "answer": "Encapsulation : principes et mise en œuvre. Pourquoi : 1) Protection des données internes, 2) Contrôle d'accès et validation, 3) Facilite maintenance et évolution, 4) Réduit couplage, 5) Améliore testabilité. Comment : attributs privés, méthodes publiques d'accès, validation dans setters, documentation des contrats, tests unitaires de l'API publique. Design by contract : préconditions, postconditions, invariants. Résultat : code plus robuste et maintenable."
            },
            {
                "question": "Comment sécuriser une API REST ?",
                "answer": "Pour sécuriser une API REST : 1) Authentification (JWT, OAuth2), 2) Autorisation basée sur les rôles (RBAC), 3) Validation stricte des entrées, 4) Rate limiting pour éviter les attaques DoS, 5) HTTPS obligatoire, 6) CORS configuré correctement, 7) Logs et monitoring des accès, 8) Versionning de l'API, 9) Gestion des erreurs sans exposer d'informations sensibles, 10) Tests de sécurité réguliers."
            },
            {
                "question": "Pourquoi et comment valider les entrées utilisateur dans une API ?",
                "answer": "Validation API critique pour : sécurité (injection, XSS), intégrité données, stabilité système, UX cohérente. Comment : 1) Validation syntaxique (format, type, longueur), 2) Validation sémantique (business rules), 3) Sanitization des entrées, 4) Whitelist validation, 5) Frameworks de validation (Bean Validation JSR-303), 6) Validation en couches (DTO, service, persistence), 7) Messages d'erreur informatifs mais non révélateurs, 8) Logging des tentatives malveillantes."
            },
            {
                "question": "Pourquoi utiliser un format JSON pour les réponses d'une API REST ?",
                "answer": "JSON privilégié pour APIs REST car : 1) Format léger et compact, 2) Support natif JavaScript, 3) Lisible humainement, 4) Largement supporté tous langages, 5) Structure flexible (objets, arrays), 6) Parsing rapide, 7) Standard web moderne, 8) Moins verbeux que XML, 9) Facilite intégration frontend, 10) Bon support tooling (validation, transformation). Alternative : XML pour enterprise, Protocol Buffers pour performance extrême."
            },
            {
                "question": "Comment sécuriser un composant métier dans une application web ?",
                "answer": "Sécurisation composant métier : 1) Validation des entrées systématique, 2) Autorisation granulaire par méthode, 3) Encapsulation des règles business, 4) Audit trail des opérations, 5) Gestion des exceptions sécurisée, 6) Principe de moindre privilège, 7) Tests de sécurité dédiés, 8) Chiffrement des données sensibles, 9) Session management approprié, 10) Logs sécurisés sans données sensibles, 11) Rate limiting par utilisateur/fonction."
            },
            {
                "question": "Quelles sont les principales failles de sécurité en développement web ?",
                "answer": "OWASP Top 10 : 1) Broken Access Control, 2) Cryptographic Failures, 3) Injection (SQL, NoSQL, LDAP), 4) Insecure Design, 5) Security Misconfiguration, 6) Vulnerable Components, 7) Authentication Failures, 8) Software/Data Integrity Failures, 9) Logging/Monitoring Failures, 10) Server-Side Request Forgery (SSRF). Prévention : formation équipe, code review sécurisé, outils SAST/DAST, pentesting régulier, veille vulnérabilités, framework sécurisé."
            },
            {
                "question": "Comment fonctionne l'authentification avec JWT ?",
                "answer": "JWT (JSON Web Token) fonctionne ainsi : 1) L'utilisateur s'authentifie avec ses identifiants, 2) Le serveur vérifie et génère un token JWT signé contenant des claims (user ID, rôles, expiration), 3) Le client stocke le token (localStorage/sessionStorage), 4) Pour chaque requête, le client envoie le token dans l'header Authorization: Bearer <token>, 5) Le serveur vérifie la signature et l'expiration, 6) Si valide, la requête est autorisée. Avantages : stateless, scalable, sécurisé."
            },
            {
                "question": "Comment gérer les autorisations côté backend avec Spring Boot ?",
                "answer": "Autorisations Spring Boot : 1) Spring Security avec @EnableGlobalMethodSecurity, 2) Annotations @PreAuthorize, @PostAuthorize, @Secured, 3) Configuration WebSecurityConfigurer, 4) Roles et Authorities via UserDetails, 5) ACL (Access Control Lists) pour granularité fine, 6) JWT Claims pour rôles, 7) Method-level security, 8) SpEL expressions pour logique complexe. Exemple : @PreAuthorize('hasRole(\"ADMIN\") or #userId == authentication.name'). Tests avec @WithMockUser."
            },
            {
                "question": "Pourquoi activer CORS dans une API backend ?",
                "answer": "CORS (Cross-Origin Resource Sharing) nécessaire car : Same-Origin Policy bloque requêtes inter-domaines par défaut pour sécurité. CORS permet : 1) Frontend et API sur domaines différents, 2) SPAs consommant APIs tierces, 3) Microservices architecture, 4) CDN et assets externes. Configuration : headers Access-Control-Allow-Origin, Allow-Methods, Allow-Headers. Spring : @CrossOrigin ou WebMvcConfigurer. Production : domaines spécifiques, pas de wildcard '*'."
            },
            {
                "question": "Pourquoi un token JWT doit-il avoir une durée de vie limitée ?",
                "answer": "JWT avec expiration courte pour : 1) Limiter impact en cas de vol/fuite, 2) Rotation sécurisée des credentials, 3) Révocation possible via refresh tokens, 4) Compliance réglementaire, 5) Principe de moindre exposition. Stratégie : access token court (15min-1h) + refresh token long (7-30j). Stockage sécurisé : httpOnly cookies > localStorage. Monitoring des tokens expirés/suspects. Balance entre sécurité et UX."
            },
            {
                "question": "Comment sécuriser une API avec OAuth2 et JWT ?",
                "answer": "OAuth2 + JWT architecture : 1) Authorization Server émet JWT après authentification, 2) Resource Server valide JWT signature et claims, 3) Scopes pour granularité permissions, 4) PKCE pour clients publics, 5) State parameter anti-CSRF, 6) TLS obligatoire, 7) Rotation des secrets, 8) Audit logs détaillés. Flows : Authorization Code (SPAs), Client Credentials (M2M). Libraries : Spring Security OAuth2, Auth0. Tests : mock JWT, test authorizations scenarios."
            },
            {
                "question": "Quelle est la différence entre le JDK et la JVM ?",
                "answer": "JVM (Java Virtual Machine) : environnement d'exécution qui interprète et exécute le bytecode Java, assure la portabilité 'Write Once, Run Anywhere', gère la mémoire et le garbage collection. JDK (Java Development Kit) : kit de développement complet qui inclut la JVM, le compilateur javac, les outils de développement (debugger, javadoc), les bibliothèques standard, et les APIs. En résumé : JDK = outils de développement + JVM, JVM = environnement d'exécution uniquement."
            },
            {
                "question": "Quelles sont les bonnes pratiques pour concevoir une API RESTful bien structurée ?",
                "answer": "API RESTful bien conçue : 1) Noms de ressources substantifs (users, orders), 2) HTTP verbs appropriés (GET, POST, PUT, DELETE), 3) Structure URLs hiérarchique (/users/123/orders), 4) Codes de statut HTTP précis, 5) Versioning dans URL ou headers, 6) Pagination, filtrage, tri, 7) HATEOAS pour discoverability, 8) Documentation OpenAPI/Swagger, 9) Validation et gestion d'erreurs consistantes, 10) Cache headers, 11) Rate limiting, 12) Tests automatisés complets."
            },
            {
                "question": "Quelles sont les différences fondamentales entre REST et GraphQL ?",
                "answer": "REST vs GraphQL : REST : multiple endpoints, over/under-fetching possible, cache HTTP natif, maturité élevée, simplicité conceptuelle. GraphQL : endpoint unique, requête précise des données, résolution N+1 potential, cache complexe, courbe apprentissage. REST meilleur pour : APIs simples, cache HTTP, équipes junior. GraphQL meilleur pour : clients multiples, données complexes, développement rapide frontend. Choisir selon : complexité données, équipe, performance requirements, écosystème existant."
            },
            {
                "question": "Quelles stratégies utiliser pour le versionnement et la compatibilité des APIs ?",
                "answer": "Stratégies versioning API : 1) URL versioning (/v1/users, /v2/users), 2) Header versioning (Accept: application/vnd.api+json;version=1), 3) Query parameter (?version=1), 4) Semantic versioning (major.minor.patch). Compatibilité : 1) Backward compatibility stricte, 2) Deprecation warnings, 3) Sunset headers, 4) Transition periods, 5) Documentation migration guides, 6) Feature flags, 7) Contract testing. Éviter breaking changes, privilegier évolution additive."
            },
            {
                "question": "Comment tester efficacement les endpoints d'une API (unitaires et intégration) ?",
                "answer": "Tests API multicouches : Unitaires : services isolés, mocks dépendances, logique métier pure. Intégration : @SpringBootTest, TestContainers pour DB, MockMvc pour HTTP layer. Contrat : Pact testing entre consumer/provider. E2E : Rest Assured, Postman/Newman. Stratégie : pyramide tests, données de test isolées, CI/CD integration, monitoring production. Outils : JUnit, Mockito, WireMock, TestContainers. Coverage : happy path + edge cases + error scenarios."
            }
        ],
        "database": [
            {
                "question": "Quelle est la différence entre un schéma conceptuel, un schéma logique et un schéma physique ?",
                "answer": "Schéma conceptuel : vue métier de haut niveau, indépendante de la technologie, modélise les entités et relations (MCD en Merise). Schéma logique : traduction du conceptuel vers un modèle de données spécifique (relationnel, NoSQL), définit tables, colonnes, contraintes (MLD en Merise). Schéma physique : implémentation technique réelle, inclut indexes, partitioning, storage, optimisations de performance (MPD en Merise). Chaque niveau ajoute des détails techniques progressivement."
            },
            {
                "question": "Quelle est la différence entre une clé primaire et une clé étrangère ?",
                "answer": "Clé primaire : identifiant unique pour chaque ligne d'une table, ne peut pas être NULL, une seule par table, assure l'intégrité d'entité. Exemple : user_id dans table Users. Clé étrangère : référence à la clé primaire d'une autre table, peut être NULL (sauf si NOT NULL), plusieurs par table, assure l'intégrité référentielle. Exemple : user_id dans table Orders qui référence Users.user_id. Les clés étrangères maintiennent la cohérence des relations entre tables."
            },
            {
                "question": "Quelles sont les principales étapes de la méthode Merise pour concevoir une base de données ?",
                "answer": "Méthode Merise : 1) Analyse des besoins et règles de gestion, 2) MCD (Modèle Conceptuel de Données) : entités, associations, cardinalités, 3) MLD (Modèle Logique de Données) : transformation en tables relationnelles, 4) MPD (Modèle Physique de Données) : implémentation SGBD spécifique, optimisations. Parallèlement : MCT (flux), MOT (organisation), MPT (technique). Validation à chaque étape, itérations possibles. Résultat : base de données normalisée et optimisée."
            },
            {
                "question": "Quelle est la différence entre une association 1-1, 1-N et N-N dans Merise ?",
                "answer": "Associations Merise : 1-1 (un-à-un) : une occurrence d'entité liée à une seule occurrence de l'autre (Personne-Passeport). 1-N (un-à-plusieurs) : une occurrence liée à plusieurs (Client-Commandes). N-N (plusieurs-à-plusieurs) : plusieurs occurrences liées à plusieurs (Étudiants-Cours). Implémentation : 1-1 et 1-N = clé étrangère, N-N = table d'association intermédiaire. Cardinalités précisent la participation (0,1 ou 1,1 ou 0,N ou 1,N)."
            },
            {
                "question": "Comment construire et modéliser une base de données relationnelle efficace ?",
                "answer": "Base de données efficace : 1) Analyse métier approfondie, 2) Normalisation (3NF minimum), 3) Choix types de données appropriés, 4) Index stratégiques, 5) Contraintes d'intégrité, 6) Dénormalisation contrôlée si nécessaire, 7) Partitioning pour gros volumes, 8) Archivage des données anciennes, 9) Tests de performance, 10) Documentation complète. Outils : ERwin, PowerDesigner, MySQL Workbench. Validation avec cas d'usage réels."
            },
            {
                "question": "Comment créer une base de données en SQL ?",
                "answer": "Pour créer une base de données en SQL : CREATE DATABASE nom_base_donnees; puis USE nom_base_donnees; pour l'utiliser. Options avancées : CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; pour l'encodage. Exemple complet : CREATE DATABASE ecommerce CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; Bonnes pratiques : utiliser des noms explicites, définir l'encodage, planifier la structure, prévoir les droits d'accès."
            },
            {
                "question": "Comment créer une table avec une clé primaire et une clé étrangère ?",
                "answer": "Création table SQL : CREATE TABLE users (id INT PRIMARY KEY AUTO_INCREMENT, nom VARCHAR(100) NOT NULL, email VARCHAR(255) UNIQUE); CREATE TABLE orders (id INT PRIMARY KEY AUTO_INCREMENT, user_id INT, amount DECIMAL(10,2), FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE); Contraintes : NOT NULL, UNIQUE, CHECK. Options FK : CASCADE, SET NULL, RESTRICT. Index automatique sur PK, recommandé sur FK."
            },
            {
                "question": "Comment protéger une base de données contre les injections SQL ?",
                "answer": "Protection contre l'injection SQL : 1) Requêtes préparées (prepared statements) - séparent code et données, 2) Validation stricte des entrées côté serveur, 3) Échappement des caractères spéciaux, 4) Utilisation d'un ORM (Hibernate, Doctrine), 5) Principe de moindre privilège pour les comptes DB, 6) Stored procedures avec paramètres, 7) Whitelist validation plutôt que blacklist, 8) Tests de sécurité réguliers, 9) Never trust user input."
            },
            {
                "question": "Quelles sont les stratégies d'optimisation des performances des bases de données SQL ?",
                "answer": "Optimisation performance SQL : 1) Index appropriés (B-tree, Hash, Bitmap), 2) Requêtes optimisées (EXPLAIN), 3) Dénormalisation contrôlée, 4) Partitioning horizontal/vertical, 5) Cache query results, 6) Connection pooling, 7) Maintenance régulière (ANALYZE, VACUUM), 8) Archivage données anciennes, 9) Hardware adapté (SSD, RAM), 10) Monitoring continu (slow query log). Mesurer avant/après optimisations."
            },
            {
                "question": "Quelles sont les meilleures pratiques pour optimiser les requêtes SQL et NoSQL ?",
                "answer": "Optimisation requêtes : SQL : 1) Index sur colonnes WHERE/JOIN, 2) Éviter SELECT *, 3) LIMIT pour pagination, 4) EXISTS vs IN selon contexte, 5) Analyze query plans. NoSQL : 1) Design orienté requêtes, 2) Index composés, 3) Sharding strategy, 4) Éviter cross-shard queries, 5) Projection fields appropriées. Général : cache, batch operations, monitoring performance, load testing. Outils : EXPLAIN, profilers, APM."
            },
            {
                "question": "Quelles sont les bonnes pratiques pour sécuriser une base de données et gérer les comptes utilisateurs ?",
                "answer": "Sécurisation base de données : 1) Comptes nominatifs avec mots de passe forts, 2) Principe de moindre privilège, 3) Rôles et permissions granulaires, 4) Rotation des mots de passe, 5) Audit des accès, 6) Chiffrement en transit (TLS) et au repos, 7) Sauvegarde chiffrées, 8) Monitoring des connexions suspectes, 9) Réseau sécurisé (VPN, firewall), 10) Maintenance sécurité régulière, 11) Formation équipes. Éviter comptes partagés."
            },
            {
                "question": "Pourquoi ne faut-il pas utiliser root pour les accès à la base de données ?",
                "answer": "Éviter root car : 1) Principe de moindre privilège violé, 2) Audit impossible (actions non traçables), 3) Risque sécuritaire énorme si compromis, 4) Pas de granularité des permissions, 5) Violation des standards sécurité, 6) Impossibilité de révoquer accès spécifiques, 7) Non-conformité réglementaire. Solution : comptes dédiés par application/utilisateur avec permissions minimales nécessaires. Root réservé aux tâches administratives ponctuelles."
            },
            {
                "question": "Pourquoi faut-il toujours valider les entrées utilisateur avant d'insérer des données en base ?",
                "answer": "Validation entrées obligatoire pour : 1) Prévention injection SQL, 2) Intégrité des données métier, 3) Cohérence format/type, 4) Respect contraintes DB, 5) Performance (éviter rollbacks), 6) Audit et conformité, 7) UX (messages d'erreur clairs), 8) Stabilité système. Validation multicouche : frontend (UX), backend (sécurité), database (intégrité). Never trust client data. Logs des tentatives malveillantes."
            },
            {
                "question": "Comment sécuriser les accès aux bases de données SQL et NoSQL ?",
                "answer": "Sécurisation accès DB : 1) Authentification forte (certificats, 2FA), 2) Autorisation granulaire (RBAC), 3) Chiffrement connexions (TLS/SSL), 4) VPN ou réseaux privés, 5) Firewall DB niveau réseau, 6) Rate limiting connexions, 7) Monitoring et alertes, 8) Audit logs détaillés, 9) Backup chiffrées hors site, 10) Patching sécurité régulier. NoSQL : attention aux configurations par défaut non sécurisées."
            },
            {
                "question": "Comment tester la sécurité et l'intégrité des accès aux bases de données ?",
                "answer": "Tests sécurité DB : 1) Tests d'intrusion automatisés, 2) Audit des permissions et rôles, 3) Vérification chiffrement, 4) Tests injection SQL/NoSQL, 5) Monitoring des accès anormaux, 6) Validation sauvegarde/restore, 7) Tests de performance sous charge, 8) Compliance checks (GDPR, PCI), 9) Penetration testing, 10) Code review accès données. Outils : SQLMap, OWASP ZAP, Nessus. Tests réguliers en CI/CD."
            },
            {
                "question": "Qu'est-ce qu'un ORM et pourquoi l'utiliser ?",
                "answer": "ORM (Object-Relational Mapping) : technique de programmation qui fait le lien entre objets métier et tables de base de données. Avantages : 1) Abstraction de la DB, code plus maintenable, 2) Protection contre l'injection SQL, 3) Portabilité entre différents SGBD, 4) Génération automatique des requêtes, 5) Gestion des relations complexes, 6) Cache de premier niveau. Inconvénients : courbe d'apprentissage, performance parfois moindre, requêtes N+1. Exemples : Hibernate (Java), Doctrine (PHP), Eloquent (Laravel)."
            },
            {
                "question": "Comment JPA crée-t-il la base et les tables dans Spring Boot ?",
                "answer": "JPA/Spring Boot création automatique : 1) spring.jpa.hibernate.ddl-auto=create/update/validate, 2) Annotations @Entity sur classes, 3) @Table pour noms spécifiques, 4) @Id @GeneratedValue pour PK, 5) @Column pour contraintes, 6) @OneToMany, @ManyToOne pour relations, 7) schema.sql pour initialisation, 8) data.sql pour données test. Environnements : create en dev, validate en prod. Attention : create DROP les tables ! Migrations Flyway/Liquibase en production."
            },
            {
                "question": "Comment accéder aux données avec JPA dans Spring Boot ?",
                "answer": "Accès données JPA Spring Boot : 1) Repository interfaces (CrudRepository, JpaRepository), 2) Méthodes de requête dérivées (findByName), 3) @Query pour requêtes personnalisées JPQL/SQL, 4) @Modifying pour UPDATE/DELETE, 5) Pagination avec Pageable, 6) Spécifications pour requêtes dynamiques, 7) @Transactional pour transactions, 8) EntityManager pour contrôle fin. Exemple : List<User> findByAgeGreaterThan(int age); Performance : Lazy loading, projections."
            },
            {
                "question": "Comment configurer la connexion à une base MySQL avec Spring Boot ?",
                "answer": "Configuration MySQL Spring Boot : application.properties : spring.datasource.url=jdbc:mysql://localhost:3306/mydb, spring.datasource.username=user, spring.datasource.password=password, spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver, spring.jpa.hibernate.ddl-auto=update, spring.jpa.show-sql=true. Dépendance Maven : mysql-connector-java. Pool connexions : HikariCP par défaut. Sécurité : variables d'environnement pour credentials, SSL si nécessaire."
            },
            {
                "question": "Comment JPA fait-il le lien entre une classe Java et une table en base de données ?",
                "answer": "Mapping JPA classe-table : 1) @Entity marque la classe persistante, 2) @Table(name=\"users\") spécifie nom table, 3) @Id identifie la clé primaire, 4) @Column(name=\"email\", unique=true) map attribut-colonne, 5) @GeneratedValue pour auto-increment, 6) @Temporal pour dates, 7) @Enumerated pour enums, 8) Relations @OneToMany/@ManyToOne, 9) @JoinColumn pour FK. Convention over configuration : User -> user table par défaut."
            },
            {
                "question": "Quelle est la différence entre une base de données SQL et NoSQL ?",
                "answer": "SQL (Relationnel) : structure tabulaire avec schéma fixe, ACID compliance, relations complexes, langage SQL standardisé, excellente consistance. Exemples : MySQL, PostgreSQL. NoSQL : schéma flexible, types variés (document, clé-valeur, graphe, colonne), scale horizontal naturel, performance élevée, eventual consistency. Exemples : MongoDB (document), Redis (clé-valeur), Cassandra (colonne), Neo4j (graphe). Choix selon : complexité des relations, volume de données, besoins de consistance, équipe de développement."
            },
            {
                "question": "Quels sont les avantages et inconvénients des procédures stockées et des triggers ?",
                "answer": "Procédures stockées : Avantages : performance (pré-compilées), sécurité (permissions granulaires), logique centralisée, réduction trafic réseau. Inconvénients : portabilité limitée, versioning complexe, debugging difficile, couplage fort DB. Triggers : Avantages : intégrité automatique, audit transparent, règles métier centralisées. Inconvénients : debugging complexe, performance impact, logique cachée, cascade effects. Usage : procédures pour traitements complexes, triggers pour contraintes business critiques."
            },
            {
                "question": "Quels sont les principaux Design Patterns pour l'accès aux bases de données et leur utilité ?",
                "answer": "Design Patterns accès données : 1) Repository : abstraction couche accès, testabilité, 2) DAO (Data Access Object) : encapsulation logique persistance, 3) Unit of Work : gestion transactions, cohérence, 4) Active Record : objet = enregistrement, simplicité, 5) Data Mapper : séparation objet/DB, flexibilité, 6) Query Object : requêtes réutilisables, 7) Connection Pool : performance connexions. Choix selon complexité, performance, testabilité. Spring Data Repository populaire."
            },
            {
                "question": "Pourquoi intégrer l'authentification et la gestion des accès dans les composants d'accès aux données ?",
                "answer": "Sécurité intégrée accès données pour : 1) Defense in depth, 2) Autorisation granulaire par donnée, 3) Audit trail complet, 4) Prévention élévation privilèges, 5) Compliance réglementaire, 6) Isolation multi-tenant. Implémentation : Spring Security method-level, Row Level Security PostgreSQL, filtres dynamiques, aspects AOP. Exemples : @PreAuthorize sur repositories, filtres utilisateur automatiques, logging accès sensibles. Équilibre sécurité/performance."
            }
        ],
        "devops": [
            {
                "question": "Pourquoi utiliser Docker pour un projet ?",
                "answer": "Docker apporte : 1) Isolation des applications dans des conteneurs légers, 2) Reproductibilité : 'ça marche sur ma machine' → 'ça marche partout', 3) Portabilité entre environnements (dev, test, prod), 4) Scalabilité horizontale facilitée, 5) Gestion simplifiée des dépendances, 6) Déploiement rapide et rollback facile, 7) Optimisation des ressources vs VMs, 8) Intégration CI/CD, 9) Microservices architecture, 10) Cohérence des environnements équipe."
            },
            {
                "question": "Quels fichiers sont nécessaires pour configurer un conteneur Docker ?",
                "answer": "Fichiers Docker essentiels : 1) Dockerfile : instructions de build (FROM, RUN, COPY, EXPOSE, CMD), 2) .dockerignore : exclusions du contexte build, 3) docker-compose.yml : orchestration multi-conteneurs, 4) docker-compose.override.yml : surcharges développement. Optionnels : entrypoint.sh (script démarrage), healthcheck scripts, variables d'environnement (.env). Structure typique : base image → dépendances → code application → configuration runtime."
            },
            {
                "question": "Pourquoi utiliser Docker dans une démarche DevOps ?",
                "answer": "Docker + DevOps = synergie parfaite : 1) Standardisation environnements dev→prod, 2) CI/CD simplifié avec images versionnées, 3) Déploiements automatisés et reproductibles, 4) Rollback instantané, 5) Scaling horizontal facilité, 6) Infrastructure as Code, 7) Monitoring unifié, 8) Tests en environnements identiques, 9) Réduction Time-to-Market, 10) Collaboration Dev/Ops améliorée. Élimination 'configuration drift' entre environnements."
            },
            {
                "question": "Qu'est-ce que docker-compose et pourquoi l'utiliser ?",
                "answer": "Docker Compose : outil d'orchestration multi-conteneurs avec fichier YAML déclaratif. Utilité : 1) Définition architecture complète (app, DB, cache, proxy), 2) Gestion des réseaux et volumes, 3) Variables d'environnement centralisées, 4) Commandes simples (up, down, scale), 5) Environnements reproductibles, 6) Développement local simplifié. Exemple : web app + PostgreSQL + Redis en une commande. Alternative : Kubernetes pour production complexe."
            },
            {
                "question": "Quels sont les avantages de Docker et comment l'utiliser dans un projet ?",
                "answer": "Avantages Docker : isolation, portabilité, efficacité ressources, versioning, scaling. Utilisation projet : 1) Dockerfile pour chaque service, 2) Multi-stage builds (build/runtime séparés), 3) Base images officielles sécurisées, 4) Secrets management, 5) Health checks, 6) Resource limits, 7) Logging centralisé, 8) Registry privé, 9) Scanning sécurité images, 10) Documentation Dockerfile. Best practices : layers minimales, user non-root, images lightweight."
            },
            {
                "question": "Comment Kubernetes facilite-t-il l'orchestration des conteneurs ?",
                "answer": "Kubernetes orchestration : 1) Déploiement automatisé (Deployments, StatefulSets), 2) Service discovery et load balancing, 3) Auto-scaling horizontal/vertical, 4) Rolling updates sans downtime, 5) Health checks et self-healing, 6) Gestion configuration (ConfigMaps, Secrets), 7) Persistence volumes, 8) Network policies, 9) RBAC sécurité, 10) Multi-cloud portabilité. Abstraction infrastructure, état désiré déclaratif, écosystème riche (Helm, Operators)."
            },
            {
                "question": "Comment mettre en place une pipeline CI/CD efficace ?",
                "answer": "Pipeline CI/CD efficace : 1) Source Control (Git) avec branches stratégiques, 2) CI : build automatique, tests unitaires/intégration, analyse qualité code (SonarQube), 3) Artefacts : création et stockage des builds, 4) CD : déploiement automatisé par environnement (dev→test→prod), 5) Tests automatisés (E2E, performance), 6) Monitoring et alertes, 7) Rollback automatique si échec, 8) Documentation et notifications équipe. Outils : Jenkins, GitLab CI, GitHub Actions, Azure DevOps."
            },
            {
                "question": "Qu'est-ce que DevOps et pourquoi l'utiliser ?",
                "answer": "DevOps est une culture et ensemble de pratiques qui rapprochent le développement (Dev) et les opérations (Ops) pour : 1) Accélérer la livraison de logiciels, 2) Améliorer la collaboration entre équipes, 3) Automatiser les processus (CI/CD), 4) Réduire les erreurs humaines, 5) Feedback rapide et amélioration continue, 6) Monitoring et observabilité, 7) Infrastructure as Code, 8) Déploiements fréquents et fiables. Bénéfices : time-to-market réduit, qualité améliorée, satisfaction client."
            },
            {
                "question": "Quelle est la différence entre Intégration Continue (CI) et Déploiement Continu (CD) ?",
                "answer": "CI (Continuous Integration) : pratique de merger fréquemment le code dans la branche principale, avec build et tests automatiques à chaque commit. Objectif : détecter les problèmes tôt. CD (Continuous Deployment/Delivery) : extension de CI qui automatise le déploiement. Continuous Delivery : code prêt à déployer, déploiement manuel. Continuous Deployment : déploiement automatique en production si tous les tests passent. CI assure la qualité, CD assure la livraison rapide."
            },
            {
                "question": "Quels outils sont utilisés pour la CI/CD ?",
                "answer": "Outils CI/CD populaires : 1) Jenkins : open-source, extensible, plugins nombreux, 2) GitLab CI : intégré Git, containers natifs, 3) GitHub Actions : workflows YAML, marketplace, 4) Azure DevOps : Microsoft ecosystem, 5) CircleCI : cloud-native, performance, 6) TeamCity : JetBrains, intégration IDE. Critères choix : écosystème existant, complexité pipelines, coûts, support équipe, intégrations tierces. Tendance : cloud-native solutions."
            },
            {
                "question": "Pourquoi automatiser les tests dans une CI/CD ?",
                "answer": "Automatisation tests CI/CD critique pour : 1) Détection précoce des régressions, 2) Feedback rapide développeurs, 3) Qualité constante releases, 4) Confiance déploiements, 5) Réduction coûts bugs production, 6) Vélocité équipe maintenue, 7) Documentation comportements attendus, 8) Non-régression fonctionnelle. Tests : unitaires (rapides), intégration (contrats), E2E (parcours critiques), performance (seuils). Gate qualité avant déploiement."
            },
            {
                "question": "Que contient un fichier CI/CD (.yaml) pour GitHub Actions ?",
                "answer": "Fichier GitHub Actions (.github/workflows/ci.yml) : name, on: [push, pull_request], jobs avec runs-on (ubuntu-latest), steps avec uses/run, actions marketplace (checkout, setup-node, cache), variables d'environnement, secrets, artifacts, matrix builds, conditions. Exemple : checkout code → setup environment → install dependencies → run tests → build → deploy. Workflows parallèles, réutilisables, intégration status checks."
            },
            {
                "question": "Qu'est-ce que le déploiement d'une application ?",
                "answer": "Déploiement application : processus de mise en production du code depuis l'environnement de développement. Étapes : 1) Build de l'application, 2) Tests qualité/sécurité, 3) Packaging (Docker, JAR, etc.), 4) Configuration environnement cible, 5) Transfert artefacts, 6) Installation/mise à jour, 7) Configuration runtime, 8) Démarrage services, 9) Tests post-déploiement, 10) Monitoring. Stratégies : blue-green, rolling, canary. Automatisation recommandée."
            },
            {
                "question": "Quelle est la différence entre un serveur et un hébergeur ?",
                "answer": "Serveur : machine physique/virtuelle exécutant des applications et services. Hébergeur : entreprise fournissant infrastructure (serveurs, réseau, sécurité, maintenance). Types hébergement : 1) Mutualisé : ressources partagées, économique, 2) Dédié : serveur exclusif, performance max, 3) VPS : virtuel isolé, équilibre prix/performance, 4) Cloud : élastique, pay-as-you-use. Serveur = hardware/software, Hébergeur = service provider."
            },
            {
                "question": "Qu'est-ce qu'un DNS et quel est son rôle ?",
                "answer": "DNS (Domain Name System) : système de résolution de noms de domaine en adresses IP. Rôle : 1) Traduction google.com → 172.217.14.110, 2) Hiérarchie distributée (root → TLD → autoritaire), 3) Cache pour performance, 4) Redondance et fiabilité, 5) Load balancing par rotation, 6) Géolocalisation traffic. Types d'enregistrements : A (IPv4), AAAA (IPv6), CNAME (alias), MX (mail), TXT (métadonnées). Essentiel pour navigation web."
            },
            {
                "question": "Qu'est-ce qu'un reverse proxy et pourquoi l'utiliser ?",
                "answer": "Un reverse proxy (ex: Nginx, HAProxy) se place devant les serveurs d'application et agit au nom du serveur. Fonctions : 1) Load balancing : distribue les requêtes entre plusieurs serveurs, 2) SSL termination : gère le chiffrement HTTPS, 3) Cache : stocke les réponses statiques, 4) Compression : réduit la bande passante, 5) Sécurité : filtre les requêtes malveillantes, 6) Rate limiting, 7) Health checks des serveurs backend. Améliore performance, sécurité et disponibilité."
            },
            {
                "question": "Comment gérer efficacement le versionnement et les mises à jour d'un logiciel ?",
                "answer": "Versionnement efficace : 1) Semantic Versioning (MAJOR.MINOR.PATCH), 2) Git flow ou GitHub flow, 3) Tags pour releases, 4) Changelog détaillé, 5) Branches de maintenance LTS, 6) Tests automatisés complets, 7) Déploiements progressifs (canary, blue-green), 8) Rollback strategy, 9) Communication utilisateurs, 10) Monitoring post-release. Mises à jour : backward compatibility, migration scripts, documentation."
            },
            {
                "question": "Quelles stratégies adopter pour une migration de logiciel sans rupture ?",
                "answer": "Migration sans rupture : 1) Strangler Pattern : remplacement progressif, 2) Blue-Green Deployment : environnements parallèles, 3) Feature Flags : activation contrôlée, 4) Database migration scripts, 5) API versioning pour compatibilité, 6) Tests de charge avant switch, 7) Rollback plan détaillé, 8) Communication stakeholders, 9) Formation équipes, 10) Monitoring intensif. Phase pilote, feedback users, validation métier. Patience et planification."
            },
            {
                "question": "Qu'est-ce que l'Infrastructure as Code et quels outils utiliser (Terraform, Ansible…) ?",
                "answer": "Infrastructure as Code (IaC) : gestion infrastructure via code déclaratif versionné. Avantages : reproductibilité, versioning, collaboration, automatisation. Outils : 1) Terraform : multi-cloud, state management, 2) Ansible : configuration management, agentless, 3) CloudFormation : AWS natif, 4) Pulumi : langages de programmation, 5) Chef/Puppet : configuration complexe. Choisir selon : cloud provider, équipe skills, complexité infrastructure. Best practices : modules, testing, state remote."
            },
            {
                "question": "Quels outils recommandes-tu pour la supervision et la gestion des logs en production ?",
                "answer": "Monitoring et logs production : 1) APM : New Relic, Datadog, AppDynamics pour performance applicative, 2) Infrastructure : Prometheus + Grafana, Nagios, Zabbix, 3) Logs : ELK Stack (Elasticsearch, Logstash, Kibana), Splunk, Fluentd, 4) Alerting : PagerDuty, OpsGenie, 5) Synthetics : tests user journey, 6) Cloud-native : CloudWatch, Azure Monitor. Centralisation, corrélation, alertes intelligentes, dashboards métier."
            },
            {
                "question": "Quels outils de monitoring et de logging recommandes-tu pour suivre les performances d'une application ?",
                "answer": "Stack monitoring moderne : 1) Métriques : Prometheus (collecte) + Grafana (visualisation), 2) Traces distribuées : Jaeger, Zipkin pour microservices, 3) Logs : ELK/EFK stack, Loki, 4) APM : New Relic, Datadog, Dynatrace pour code-level insights, 5) Synthetics : Pingdom, Uptime Robot, 6) Real User Monitoring (RUM), 7) Infrastructure : Node Exporter, cAdvisor. Corrélation métriques/logs/traces cruciale pour troubleshooting."
            },
            {
                "question": "Quelles sont les stratégies de mise en cache pour améliorer les performances d'une application ?",
                "answer": "Stratégies cache multicouche : 1) Browser cache : CSS/JS/images avec Cache-Control, 2) CDN : géodistribution contenu statique, 3) Reverse proxy cache : Varnish, Nginx, 4) Application cache : Redis, Memcached pour données fréquentes, 5) Database query cache, 6) Object cache : ORM L1/L2, 7) HTTP cache : ETags, Last-Modified. Patterns : cache-aside, write-through, write-behind. Invalidation strategy cruciale. Mesurer hit ratio."
            },
            {
                "question": "Comment fonctionne le load balancing et quand l'utiliser ?",
                "answer": "Le load balancing distribue le trafic entre plusieurs serveurs selon différents algorithmes : Round Robin (rotation), Least Connections (moins de connexions), IP Hash (basé sur IP client), Weighted (pondéré par capacité). Types : Layer 4 (transport) ou Layer 7 (application). Utiliser quand : 1) Trafic élevé dépassant un serveur, 2) Besoin de haute disponibilité, 3) Architecture microservices, 4) Maintenance sans interruption, 5) Scaling horizontal. Outils : AWS ALB/NLB, Nginx, HAProxy, Cloudflare."
            }
        ],
        "architecture": [
            {
                "question": "Quels sont les principes des architectures logicielles multicouches ?",
                "answer": "Architecture multicouches (n-tier) organise l'application en couches distinctes : 1) Présentation : interface utilisateur (UI/UX), 2) Logique métier : règles de gestion et traitements, 3) Accès aux données : persistance et récupération. Principes : séparation des responsabilités, couplage faible, cohésion forte, réutilisabilité, maintenabilité. Chaque couche ne communique qu'avec les couches adjacentes. Avantages : modularité, testabilité, évolutivité, équipes spécialisées."
            },
            {
                "question": "Quel est l'intérêt d'une architecture en couches ?",
                "answer": "Architecture en couches bénéfique pour : 1) Séparation des responsabilités claire, 2) Réutilisabilité des composants, 3) Maintenance facilitée par isolation, 4) Tests indépendants par couche, 5) Évolutivité contrôlée, 6) Équipes spécialisées par couche, 7) Sécurité renforcée (defense in depth), 8) Performance optimisable par couche, 9) Documentation simplifiée, 10) Respect des standards architecturaux. Facilite compréhension et maintenance long terme."
            },
            {
                "question": "Quelle est la différence entre une architecture monolithique et une architecture en microservices ?",
                "answer": "Monolithique : application déployée comme une seule unité, toutes les fonctionnalités dans un même processus. Avantages : simplicité développement/déploiement, performance interne élevée. Inconvénients : scaling difficile, technologies figées, risque de panne globale. Microservices : application découpée en services indépendants communicant par APIs. Avantages : scaling granulaire, technologies variées, résilience, équipes autonomes. Inconvénients : complexité réseau, gestion distribuée, debugging complexe. Choix selon taille équipe et complexité métier."
            },
            {
                "question": "Quelles sont les principales couches d'une architecture logicielle multicouche ?",
                "answer": "Couches architecture multicouche typique : 1) Présentation : UI, contrôleurs, formatage données, 2) Application/Service : orchestration, workflows, APIs, 3) Métier/Domaine : règles business, entités, logique core, 4) Persistance/Données : repositories, DAO, mapping ORM, 5) Infrastructure : base de données, filesystem, services externes. Variantes : MVC, MVP, MVVM, Clean Architecture, Hexagonal. Communication unidirectionnelle descendante recommandée."
            },
            {
                "question": "Quels sont les principes d'architecture d'une application SaaS et leurs avantages ?",
                "answer": "Architecture SaaS : 1) Multi-tenancy : isolation données clients, 2) Élasticité : scaling automatique, 3) API-first : intégrations facilitées, 4) Microservices : déploiements indépendants, 5) Event-driven : asynchrone, découplage, 6) Cloud-native : containers, orchestration, 7) Security by design : chiffrement, RBAC, 8) Observabilité : monitoring, logs, metrics. Avantages : coûts réduits, mises à jour centralisées, accessibilité globale, scalabilité, time-to-market rapide."
            },
            {
                "question": "Comment sécuriser une architecture logicielle ?",
                "answer": "Sécurisation architecture : 1) Defense in depth : sécurité multicouche, 2) Principe de moindre privilège, 3) Zero Trust : vérifier tout, ne rien supposer, 4) Chiffrement en transit (HTTPS) et au repos, 5) Authentification forte et autorisation granulaire, 6) Segmentation réseau et firewalls, 7) Logs centralisés et monitoring, 8) Gestion des secrets (Vault), 9) Updates sécurité régulières, 10) Tests de pénétration, 11) Backup et plan de continuité, 12) Formation équipes sécurité."
            },
            {
                "question": "Quelles sont les principales vulnérabilités des architectures multicouches et comment les prévenir ?",
                "answer": "Vulnérabilités multicouches : 1) Injection attacks (SQL, NoSQL, LDAP) → prepared statements, validation, 2) Broken authentication → MFA, session management, 3) Data exposure → chiffrement, access control, 4) API abuse → rate limiting, validation, 5) Privilege escalation → RBAC, audit, 6) Man-in-the-middle → TLS, certificate pinning. Prévention : security by design, code reviews, SAST/DAST tools, penetration testing, security training."
            },
            {
                "question": "Comment adapter une architecture logicielle aux exigences de sécurité de l'ANSSI ?",
                "answer": "Conformité ANSSI : 1) Référentiel RGS (Référentiel Général de Sécurité), 2) Classification données (DR, Confidentiel, Secret), 3) Homologation sécurité obligatoire, 4) Chiffrement qualifié (algorithmes ANSSI), 5) Architecture cloisonnée, 6) Audit et traçabilité, 7) Plan de continuité/reprise, 8) Formation personnels habilités, 9) Gestion des incidents, 10) Revues sécurité régulières. Documentation détaillée, tests conformité, certification produits."
            },
            {
                "question": "Quels sont les principaux indicateurs de sécurité des systèmes d'information (DICP) ?",
                "answer": "DICP (Disponibilité, Intégrité, Confidentialité, Preuve) : 1) Disponibilité : uptime, RTO/RPO, redondance, 2) Intégrité : checksums, signatures numériques, contrôles cohérence, 3) Confidentialité : chiffrement, access control, classification, 4) Preuve/Non-répudiation : signatures, audit trails, timestamps. Métriques : taux incidents, temps résolution, niveau conformité, coûts sécurité. Balance entre sécurité et usabilité selon criticité métier."
            },
            {
                "question": "Quels outils peux-tu utiliser pour modéliser une architecture logicielle ?",
                "answer": "Outils de modélisation architecture : 1) UML : diagrammes de composants, déploiement, séquence (Lucidchart, Draw.io), 2) C4 Model : Context, Containers, Components, Code (PlantUML, Structurizr), 3) ArchiMate : framework enterprise (Archi, BiZZdesign), 4) Diagrammes d'architecture cloud (AWS/Azure/GCP tools), 5) Miro/Mural pour ateliers collaboratifs, 6) Enterprise Architect pour grandes organisations, 7) Draw.io gratuit et efficace, 8) Visio Microsoft. Important : choisir selon audience et niveau de détail requis."
            },
            {
                "question": "Quels principes d'éco-conception peux-tu appliquer dans une architecture logicielle ?",
                "answer": "Éco-conception logicielle : 1) Optimisation algorithmes (complexité réduite), 2) Lazy loading et pagination, 3) Cache intelligent pour réduire calculs, 4) Compression données/images, 5) Base de données optimisées (index, requêtes), 6) Architecture serverless/cloud-native, 7) Monitoring consommation énergétique, 8) Code quality (moins de bugs = moins de ressources), 9) Lifecycle management données, 10) Green hosting providers. Mesurer impact carbone, optimiser performance = écologie."
            }
        ],
        "tests": [
            {
                "question": "Qu'est-ce qu'un plan de tests et pourquoi est-il important ?",
                "answer": "Un plan de tests est un document détaillant la stratégie, l'approche, les ressources et le calendrier des activités de test. Il contient : objectifs, périmètre, types de tests, environnements, critères d'entrée/sortie, risques, planning. Importance : 1) Assure la couverture complète des fonctionnalités, 2) Optimise les ressources et le temps, 3) Définit les responsabilités, 4) Facilite la communication équipe, 5) Permet le suivi de la qualité, 6) Réduit les risques de régression, 7) Standardise les processus."
            },
            {
                "question": "Quels sont les types de tests inclus dans un plan de tests ?",
                "answer": "Types de tests dans un plan : 1) Tests fonctionnels : unitaires, intégration, système, acceptation, 2) Tests non-fonctionnels : performance, charge, stress, sécurité, compatibilité, 3) Tests structurels : boîte blanche, couverture de code, 4) Tests de changement : régression, confirmation, 5) Tests spécialisés : accessibilité, utilisabilité, installation, 6) Tests automatisés vs manuels. Chaque type répond à des objectifs spécifiques et couvre différents aspects de la qualité logicielle."
            },
            {
                "question": "Quelle est la différence entre un test unitaire et un test d'intégration ?",
                "answer": "Test unitaire : teste une unité de code isolée (fonction, méthode, classe) avec des dépendances mockées. Caractéristiques : rapide, déterministe, nombreux, scope limité. Exemple : tester une fonction de calcul. Test d'intégration : teste l'interaction entre plusieurs composants ou modules. Types : intégration de composants, systèmes, APIs. Plus lents mais vérifient les contrats entre modules. Pyramide des tests : nombreux tests unitaires → quelques tests intégration → peu de tests E2E."
            },
            {
                "question": "Quelle est la différence entre un test manuel et un test automatisé ?",
                "answer": "Test manuel : exécuté par un humain, interaction directe avec l'application, détecte problèmes UX/UI, créativité dans les scénarios, coûteux en temps. Adapté pour : tests exploratoires, utilisabilité, acceptation utilisateur. Test automatisé : exécuté par des scripts/outils, répétable, rapide, intégrable CI/CD, ROI élevé à long terme. Adapté pour : régression, performance, tests répétitifs. Stratégie hybride recommandée : automatiser les cas standards, garder manuel pour l'exploration et validation UX."
            },
            {
                "question": "Quelle est la différence entre tests unitaires, d'intégration, fonctionnels et E2E ?",
                "answer": "Tests unitaires : unité de code isolée, rapides, nombreux. Tests d'intégration : interaction entre composants, APIs, DB. Tests fonctionnels : validation des exigences métier, comportement attendu. Tests E2E : parcours utilisateur complet de bout en bout, interface réelle. Pyramide : beaucoup d'unitaires (base), moins d'intégration/fonctionnels (milieu), peu d'E2E (sommet). Chaque niveau a un coût et une valeur différents. Stratégie équilibrée pour couverture optimale."
            },
            {
                "question": "Qu'est-ce qu'un test de charge ?",
                "answer": "Test de charge : évalue le comportement d'un système sous une charge normale et pic attendue. Objectifs : 1) Identifier les goulots d'étranglement, 2) Valider les temps de réponse, 3) Vérifier la stabilité sous charge, 4) Déterminer la capacité maximale. Types : charge normale, stress (au-delà capacité), spike (pics soudains), volume (gros datasets). Outils : JMeter, LoadRunner, k6, Gatling. Métriques : temps de réponse, throughput, utilisation ressources, taux d'erreur."
            },
            {
                "question": "Pourquoi réaliser des tests unitaires sur un composant métier ?",
                "answer": "Tests unitaires sur composants métier essentiels pour : 1) Validation des règles de gestion complexes, 2) Détection précoce des erreurs logiques, 3) Documentation vivante du comportement attendu, 4) Facilitation des refactors sans crainte, 5) Regression testing automatique, 6) Confiance dans les modifications, 7) Debugging facilité (isolation des problèmes), 8) Respect des spécifications métier. Les composants métier étant le cœur de l'application, leur fiabilité est critique."
            },
            {
                "question": "Qu'est-ce que le Test-Driven Development (TDD) ?",
                "answer": "TDD est une pratique de développement qui suit le cycle Red-Green-Refactor : 1) Red : écrire un test qui échoue pour une fonctionnalité non implémentée, 2) Green : écrire le code minimal pour faire passer le test, 3) Refactor : améliorer le code tout en gardant les tests verts. Avantages : code testé à 100%, design émergent, documentation vivante, confiance dans les refactors, bugs détectés tôt. Discipline requise mais améliore significativement la qualité du code."
            },
            {
                "question": "Quelles sont les bonnes pratiques du Test-Driven Development (TDD) et comment l'implémenter ?",
                "answer": "Bonnes pratiques TDD : 1) Tests simples et focalisés (une assertion par test), 2) Noms de tests explicites et métier, 3) Arrange-Act-Assert structure, 4) Red-Green-Refactor strict (ne pas sauter d'étapes), 5) Refactor tests ET code, 6) Tests indépendants (pas d'ordre d'exécution), 7) Mock les dépendances externes. Implémentation : outils (JUnit, Jest), IDE supportant TDD, pratique en pair programming, formation équipe, adoption progressive sur nouveaux composants."
            },
            {
                "question": "Qu'est-ce que le mocking et comment gérer les dépendances dans les tests ?",
                "answer": "Le mocking consiste à remplacer les dépendances externes par des objets simulés (mocks) pour isoler l'unité testée. Types : Mock (vérification comportement), Stub (retourne des données prédéfinies), Spy (observateur), Fake (implémentation simplifiée). Gestion dépendances : 1) Injection de dépendances, 2) Mocking des APIs/DB, 3) Frameworks : Mockito (Java), Sinon (JS), 4) Test doubles pour services externes, 5) Fixtures pour données test. Objectif : tests rapides, déterministes, isolés."
            },
            {
                "question": "Comment créer un environnement de test ?",
                "answer": "Création environnement test : 1) Isolation (base de données test séparée), 2) Données de test reproductibles (fixtures, factories), 3) Configuration spécifique (properties/env vars), 4) Dépendances mockées/stubbed, 5) Nettoyage automatique après tests, 6) Parallélisation possible, 7) CI/CD integration, 8) Docker pour reproductibilité. Stratégies : base in-memory (H2), TestContainers, environnements éphémères cloud. Principe : tests doivent être indépendants et répétables."
            },
            {
                "question": "Que faire si un test échoue ?",
                "answer": "Quand un test échoue : 1) Analyser le message d'erreur précisément, 2) Reproduire l'échec localement, 3) Vérifier si c'est un vrai bug ou test défaillant, 4) Debugger avec breakpoints/logs, 5) Corriger le code ou ajuster le test, 6) Relancer tous les tests impactés, 7) Documenter la cause si complexe, 8) Ne jamais ignorer/commenter un test qui échoue. En CI : bloquer le merge/déploiement, notifier l'équipe, analyser les logs de build."
            },
            {
                "question": "Quels outils et frameworks recommandes-tu pour automatiser les tests ?",
                "answer": "Outils tests par type : Unitaires : JUnit (Java), Jest (JS), pytest (Python), xUnit (.NET). Intégration : TestNG, Mockito, WireMock. E2E : Selenium, Cypress, Playwright, Puppeteer. Performance : JMeter, k6, Gatling. API : Rest Assured, Postman/Newman, Insomnia. Mobile : Appium, Espresso, XCTest. CI/CD : intégration native Jenkins/GitHub Actions. Runners : Maven Surefire, npm test. Choix selon : langage, type app, équipe skills, écosystème existant."
            },
            {
                "question": "Comment organiser et prioriser les tests en méthodologie Agile ?",
                "answer": "Organisation tests Agile : 1) Pyramide des tests (beaucoup unitaires, moins E2E), 2) Tests dans Definition of Done, 3) Acceptance criteria = scenarios de test, 4) Test automation dans sprints, 5) Régression automatisée continue. Priorisation : 1) Fonctionnalités critiques d'abord, 2) Risques métier élevés, 3) Zones de code instables, 4) User stories prioritaires. Pratiques : BDD (Behavior Driven Development), ATDD (Acceptance Test Driven Development), tests exploratoires en fin de sprint."
            }
        ],
        "security": [
            {
                "question": "Pourquoi utiliser HTTPS au lieu de HTTP ?",
                "answer": "HTTPS (HTTP + SSL/TLS) apporte : 1) Chiffrement des données en transit, protection contre l'écoute, 2) Authentification du serveur via certificats, 3) Intégrité des données, détection des modifications, 4) Confiance utilisateur (cadenas vert), 5) SEO amélioré (Google favorise HTTPS), 6) APIs modernes l'exigent (geolocation, camera), 7) Conformité réglementaire (RGPD), 8) Protection contre man-in-the-middle attacks. HTTP est obsolète et non sécurisé pour les données sensibles."
            },
            {
                "question": "Pourquoi ne jamais stocker un mot de passe en clair et comment le sécuriser ?",
                "answer": "Risques du stockage en clair : vol de base de données expose tous les mots de passe, non-conformité RGPD, responsabilité légale. Sécurisation : 1) Hachage avec sel (bcrypt, Argon2, scrypt), 2) Coût computationnel élevé contre bruteforce, 3) Sel unique par mot de passe, 4) Politique de mots de passe forts, 5) Authentification multi-facteurs (2FA), 6) Rotation régulière, 7) Détection de fuites (Have I Been Pwned), 8) Chiffrement de la base de données."
            },
            {
                "question": "Quelles sont les bonnes pratiques pour définir un mot de passe sécurisé ?",
                "answer": "Mot de passe sécurisé : 1) Longueur minimale 12-16 caractères, 2) Mélange majuscules, minuscules, chiffres, symboles, 3) Éviter informations personnelles et mots du dictionnaire, 4) Unique par service, 5) Passphrase mémorable avec mots aléatoires, 6) Gestionnaire de mots de passe recommandé, 7) Vérification force en temps réel, 8) Pas de stockage en clair, 9) Expiration périodique pour comptes sensibles, 10) Formation utilisateurs sensibilisation sécurité."
            },
            {
                "question": "Comment intégrer la cryptographie et la gestion des identités dans une application sécurisée ?",
                "answer": "Intégration crypto et identités : 1) PKI (Public Key Infrastructure) pour certificats, 2) HSM (Hardware Security Module) pour clés sensibles, 3) Chiffrement asymétrique pour échange clés, 4) Chiffrement symétrique pour données, 5) Signatures numériques pour intégrité, 6) SSO/SAML/OAuth2 pour fédération identités, 7) LDAP/Active Directory pour annuaires, 8) MFA obligatoire, 9) Rotation automatique des clés, 10) Audit trails chiffrés, 11) Vault pour secrets management."
            },
            {
                "question": "Comment implémenter un système de gestion des permissions efficace ?",
                "answer": "Système permissions efficace : 1) RBAC (Role-Based Access Control) avec rôles métier, 2) ABAC (Attribute-Based) pour règles complexes, 3) Principe moindre privilège par défaut, 4) Héritage hiérarchique des permissions, 5) Permissions granulaires (CRUD par ressource), 6) Délégation contrôlée de permissions, 7) Audit et révision régulière, 8) Interface admin intuitive, 9) Tests automatisés des autorisations, 10) Documentation des rôles/permissions, 11) Workflow d'approbation pour changements sensibles."
            },
            {
                "question": "Quelles sont les meilleures pratiques pour sécuriser les données sensibles en transit et au repos ?",
                "answer": "Données en transit : 1) TLS 1.3 minimum, 2) Certificate pinning, 3) VPN pour réseaux non sûrs, 4) API Gateway avec chiffrement bout-en-bout. Données au repos : 1) Chiffrement filesystem (BitLocker, FileVault), 2) Chiffrement base de données (TDE), 3) Clés de chiffrement séparées des données, 4) Backup chiffrées, 5) Destruction sécurisée, 6) Classification des données (public, confidentiel, secret), 7) Access control granulaire, 8) Audit des accès, 9) Tokenization pour données sensibles."
            },
            {
                "question": "Quels sont les défis spécifiques à la sécurité des applications mobiles et PWA ?",
                "answer": "Défis mobiles/PWA : 1) Stockage local non sécurisé (keychain, encrypted preferences), 2) Communication réseau sur WiFi publics, 3) Jailbreak/Root detection, 4) Reverse engineering apps, 5) Certificate pinning contournement, 6) Biométrie et authentification locale, 7) Updates sécurité fragmentées, 8) Permissions excessives, 9) Code obfuscation nécessaire, 10) Service Workers et cache PWA, 11) APIs sensibles du navigateur, 12) CSP (Content Security Policy) strict, 13) Tests sur devices physiques multiples."
            },
            {
                "question": "Comment détecter et corriger les failles de sécurité dans une application en production ?",
                "answer": "Détection failles production : 1) SIEM (Security Information Event Management), 2) WAF (Web Application Firewall) avec logs, 3) Monitoring anomalies comportementales, 4) Vulnerability scanning automatisé, 5) Bug bounty programs, 6) Pentest réguliers, 7) Code review sécurité, 8) Dependency checking (Snyk, OWASP Dependency Check). Correction : 1) Incident response plan, 2) Patch management rapide, 3) Rollback procédures, 4) Communication transparent, 5) Post-mortem et amélioration continue, 6) Monitoring renforcé post-correction."
            },
            {
                "question": "Quel est le rôle de l'ANSSI et pourquoi suivre ses recommandations ?",
                "answer": "L'ANSSI (Agence Nationale de la Sécurité des Systèmes d'Information) est l'autorité française de cybersécurité. Rôles : 1) Protection des systèmes d'information de l'État, 2) Réglementation et certification sécurité, 3) Veille sur les menaces cyber, 4) Accompagnement des organismes publics et privés, 5) Incident response national. Suivre ses recommandations : conformité réglementaire, bonnes pratiques éprouvées, protection contre menaces actuelles, crédibilité auprès des clients/partenaires, éviter sanctions."
            },
            {
                "question": "Quelles sont les obligations du RGPD pour une application qui stocke des données utilisateurs ?",
                "answer": "Obligations RGPD : 1) Consentement explicite et révocable, 2) Finalité définie et proportionnelle, 3) Durée de conservation limitée, 4) Droit d'accès, rectification, effacement ('droit à l'oubli'), 5) Portabilité des données, 6) Notification violation sous 72h, 7) DPO si traitement à grande échelle, 8) Analyse d'impact (DPIA) si risque élevé, 9) Privacy by design, 10) Registre des traitements, 11) Amendes jusqu'à 4% du CA mondial. Documentation et preuves de conformité essentielles."
            },
            {
                "question": "Quelles obligations le RGPD impose-t-il pour une interface utilisateur ?",
                "answer": "RGPD pour interfaces : 1) Consentement granulaire par finalité (cookies, analytics, marketing), 2) Interfaces de gestion du consentement claires, 3) Information transparente sur collecte/usage, 4) Accès facilité aux paramètres de confidentialité, 5) Export/suppression données en self-service, 6) Formulaires avec finalités explicites, 7) Opt-in par défaut (pas de cases pré-cochées), 8) Bannières cookies conformes, 9) Langue locale et compréhensible, 10) Design patterns respectueux (dark patterns interdits), 11) Accessibilité des fonctions RGPD."
            },
            {
                "question": "Quelles obligations légales dois-tu respecter lors de la conception d'une interface ?",
                "answer": "Obligations légales interfaces : 1) RGPD (protection données personnelles), 2) Accessibilité numérique (RGAA en France, WCAG internationalement), 3) Mentions légales obligatoires, 4) CGU/CGV conformes, 5) Cookies et traceurs (consentement CNIL), 6) Droit à l'oubli implémenté, 7) Sécurité des mineurs, 8) Anti-discrimination (conception inclusive), 9) Propriété intellectuelle respectée, 10) E-commerce : informations obligatoires, délai rétractation, 11) Hébergement : identification hébergeur, 12) Archivage légal selon secteur d'activité."
            }
        ],
        "design": [
            {
                "question": "Pourquoi réaliser des maquettes avant de coder ?",
                "answer": "Réaliser des maquettes avant le développement : 1) Valide l'idée avec les parties prenantes tôt, 2) Détecte les problèmes UX avant le code, 3) Facilite la communication équipe/client, 4) Estime mieux les coûts et délais, 5) Guide le développement avec une vision claire, 6) Permet les itérations rapides et peu coûteuses, 7) Évite les malentendus et refonte, 8) Teste l'utilisabilité en amont, 9) Optimise l'architecture technique. Coût minime vs bénéfices énormes."
            },
            {
                "question": "Quelle est la différence entre un wireframe et une maquette ?",
                "answer": "Wireframe : structure schématique en noir et blanc, focus sur layout et hiérarchie de l'information, sans couleurs ni images finales. Objectif : architecture de l'information et navigation. Maquette : design visuel détaillé avec couleurs, typographies, images réelles, représentation fidèle du rendu final. Prototype : maquette interactive avec transitions et comportements. Progression : Wireframe → Maquette → Prototype → Développement. Chaque étape ajoute du détail et valide différents aspects."
            },
            {
                "question": "Quelle est la différence entre une maquette et un prototype ?",
                "answer": "Maquette : représentation visuelle statique haute-fidélité avec design final (couleurs, typographies, images), montre l'apparence exacte. Prototype : version interactive de la maquette avec navigation, transitions, animations, simule le comportement réel. Types de prototypes : 1) Basse fidélité (wireframes cliquables), 2) Haute fidélité (proche du produit final), 3) Fonctionnel (avec vraies données). Outils : Figma, Adobe XD, Principle, Framer. Prototype permet validation UX avant développement."
            },
            {
                "question": "Que contient un dossier de conception ?",
                "answer": "Dossier de conception contient : 1) Brief et cahier des charges, 2) Personas et user journey maps, 3) Benchmarks concurrentiels, 4) Arborescence et architecture information, 5) Wireframes et user flows, 6) Maquettes haute fidélité toutes résolutions, 7) Prototype interactif, 8) Charte graphique et style guide, 9) Spécifications techniques (espacements, couleurs, fonts), 10) Assets exportés (icônes, images), 11) Documentation développeurs, 12) Tests utilisateurs et recommandations."
            },
            {
                "question": "Quels outils de maquettage utiliser et comment les intégrer dans un projet ?",
                "answer": "Outils maquettage : 1) Figma : collaboratif, web-based, components/variants, 2) Adobe XD : écosystème Adobe, prototypage avancé, 3) Sketch : Mac only, plugins riches, 4) Framer : prototypage complexe avec code. Intégration projet : 1) Librairies de composants partagées, 2) Design system synchronisé, 3) Handoff développeurs (inspect mode), 4) Versioning et feedback clients, 5) Export assets automatisé, 6) Specs développeurs générées, 7) Tests utilisateurs sur prototypes, 8) Validation continue design/développement."
            },
            {
                "question": "Quelle est la différence entre UI et UX ?",
                "answer": "UI (User Interface) : aspect visuel et interactif, design des éléments graphiques, couleurs, typographies, boutons, animations. Focus sur l'esthétique et l'utilisabilité immédiate. UX (User Experience) : expérience globale utilisateur, parcours, émotions, efficacité, satisfaction. Inclut recherche utilisateur, architecture de l'information, tests d'utilisabilité. UX = stratégie et recherche, UI = implémentation visuelle. UX définit ce que fait le produit, UI définit comment il apparaît. Collaboration étroite nécessaire."
            },
            {
                "question": "Quels principes ergonomiques faut-il respecter pour une bonne expérience utilisateur ?",
                "answer": "Principes ergonomiques UX : 1) Simplicité et clarté (loi de Hick), 2) Cohérence interface et interactions, 3) Feedback immédiat sur actions, 4) Contrôle utilisateur (undo/redo), 5) Prévention erreurs et récupération, 6) Reconnaissance plutôt que rappel, 7) Flexibilité pour experts/novices, 8) Design esthétique et minimaliste, 9) Aide et documentation accessibles, 10) Navigation intuitive, 11) Hiérarchie visuelle claire, 12) Affordances évidentes, 13) Loi de Fitts (cibles importantes grandes), 14) Gestalt principles."
            },
            {
                "question": "Comment analyser un cahier des charges et formaliser les besoins utilisateurs ?",
                "answer": "Analyse cahier des charges : 1) Extraction objectifs métier et contraintes, 2) Identification personas et contextes usage, 3) Mapping besoins fonctionnels/non-fonctionnels, 4) User stories avec acceptance criteria. Formalisation besoins : 1) Personas détaillées avec jobs-to-be-done, 2) User journey maps avec pain points, 3) Functional requirements documentés, 4) User stories priorisées (MoSCoW), 5) Wireflows et task flows, 6) Matrices de traçabilité, 7) Prototypes validation concept, 8) Tests utilisateurs early feedback. Méthodes : interviews, observations, surveys, card sorting."
            },
            {
                "question": "Quelles sont les normes d'accessibilité à respecter pour concevoir une interface inclusive ?",
                "answer": "Normes d'accessibilité (WCAG 2.1) : 1) Perceptible : alternatives textuelles pour images, contrastes suffisants (4.5:1), texte redimensionnable, 2) Utilisable : navigation au clavier, pas de clignotements, délais suffisants, 3) Compréhensible : texte lisible, navigation prévisible, aide à la saisie, 4) Robuste : compatible avec technologies d'assistance. En France : RGAA (Référentiel Général d'Amélioration de l'Accessibilité). Tests avec lecteurs d'écran, validation HTML, audit accessibilité. Bénéficie à tous les utilisateurs."
            },
            {
                "question": "Quels éléments composent une charte graphique ?",
                "answer": "Charte graphique contient : 1) Logo : versions, variations, utilisation correcte/incorrecte, 2) Couleurs : palette principale/secondaire, codes RGB/CMYK/Pantone, 3) Typographies : familles, hiérarchie, tailles, 4) Iconographie : style, pictogrammes, illustrations, 5) Layouts : grilles, espacements, marges, 6) Photographie : style, traitement, cadrages, 7) Éléments graphiques : motifs, textures, 8) Applications : papeterie, digital, signalétique. Guide l'identité visuelle cohérente sur tous supports."
            }
        ],
        "project": [
            {
                "question": "Comment planifies-tu les tâches de développement d'un projet ?",
                "answer": "Planification développement : 1) Décomposition fonctionnalités en user stories, 2) Estimation effort (story points, planning poker), 3) Priorisation selon valeur métier (MoSCoW), 4) Sprint planning avec capacité équipe, 5) Backlog refinement régulier, 6) Identification dépendances et blocages, 7) Definition of Done claire, 8) Buffer pour imprévus (20%), 9) Roadmap long terme avec milestones, 10) Rétrospectives pour amélioration continue. Outils : Jira, Azure DevOps, Trello, roadmaps visuels."
            },
            {
                "question": "Quelle est la différence entre une gestion de projet séquentielle et Agile ?",
                "answer": "Gestion séquentielle (Waterfall) : phases linéaires (analyse→conception→développement→test→déploiement), planification complète en amont, changements difficiles. Avantages : prévisibilité, documentation complète. Inconvénients : rigidité, feedback tardif, risque d'inadéquation. Agile : itérations courtes (sprints), adaptabilité aux changements, collaboration client continue, livraisons fréquentes. Avantages : flexibilité, feedback rapide, valeur métier continue. Choix selon : complexité projet, stabilité exigences, équipe."
            },
            {
                "question": "Quelle est la différence entre une approche séquentielle et Agile en gestion de projet ?",
                "answer": "Approche séquentielle : 1) Phases successives avec gates, 2) Planification détaillée initiale, 3) Changements coûteux, 4) Validation finale, 5) Documentation extensive, 6) Équipes spécialisées par phase. Agile : 1) Itérations courtes et adaptatives, 2) Planification émergente, 3) Changements encouragés, 4) Feedback continu, 5) Documentation juste suffisante, 6) Équipes cross-fonctionnelles. Hybride possible : phases macro avec sprints internes, SAFe pour grandes organisations."
            },
            {
                "question": "Qu'est-ce qu'un daily meeting en Agile ?",
                "answer": "Daily meeting (stand-up) : réunion quotidienne de 15 minutes max avec l'équipe de développement. 3 questions par membre : 1) Qu'ai-je fait hier ? 2) Que vais-je faire aujourd'hui ? 3) Quels obstacles rencontré-je ? Objectifs : synchronisation équipe, identification des blocages, ajustement quotidien, amélioration collaboration. Règles : debout pour la brièveté, même heure/lieu, focus sur les tâches pas les détails techniques, résolution problèmes après la réunion. Facilite la transparence et l'entraide."
            },
            {
                "question": "Quels outils peux-tu utiliser pour gérer un projet en équipe ?",
                "answer": "Outils gestion projet : 1) Planification : Jira, Asana, Trello, Monday.com, 2) Communication : Slack, Microsoft Teams, Discord, 3) Versioning : Git (GitHub, GitLab, Bitbucket), 4) Documentation : Confluence, Notion, Wiki, 5) Design : Figma, Adobe XD, 6) CI/CD : Jenkins, GitHub Actions, 7) Monitoring : New Relic, Datadog, 8) Files : Google Drive, SharePoint, 9) Temps : Toggl, Harvest. Choix selon taille équipe, budget, intégrations nécessaires. Important : éviter la sur-outillage."
            },
            {
                "question": "Quels sont les principaux outils de gestion de projet informatique ?",
                "answer": "Outils gestion projet IT : 1) Planification : Microsoft Project, Smartsheet pour Gantt complexes, 2) Agile : Jira, Azure DevOps, Rally, VersionOne, 3) Collaboration : Confluence, SharePoint, Notion, 4) Communication : Slack, Teams, Mattermost, 5) Temps/Budget : Toggl, Harvest, Clockify, 6) Ressources : Resource Guru, Float, 7) Risques : Risk Register, Monte Carlo simulations, 8) Portfolio : Clarity, ServiceNow PPM. Intégration ecosystem crucial pour efficacité."
            },
            {
                "question": "Comment organiser et animer une réunion efficace dans un projet informatique ?",
                "answer": "Réunion efficace : Avant : 1) Objectif clair et agenda partagé, 2) Participants pertinents uniquement, 3) Durée limitée (25/50min), 4) Documentation préparatoire. Pendant : 1) Timeboxing strict, 2) Facilitateur neutre, 3) Parking lot pour hors-sujet, 4) Actions/décisions notées. Après : 1) Compte-rendu avec actions/responsables/deadlines, 2) Suivi dans outils projet, 3) Feedback réunion. Types spécialisés : sprint planning, retrospective, demo, architecture decision records. Remote : outils collaboratifs, caméras obligatoires."
            },
            {
                "question": "Comment assurer la qualité du code dans un projet ?",
                "answer": "Qualité code : 1) Standards de codage et conventions équipe, 2) Code reviews systématiques (pull requests), 3) Tests automatisés (unitaires, intégration, E2E), 4) Analyse statique de code (SonarQube, ESLint), 5) CI/CD avec gates qualité, 6) Pair programming ou mob programming, 7) Refactoring régulier, 8) Documentation technique à jour, 9) Formation continue équipe, 10) Métriques qualité (couverture tests, complexité cyclomatique). Culture qualité plus importante que les outils."
            },
            {
                "question": "Pourquoi est-il important de rédiger de la documentation technique dans un projet ?",
                "answer": "Documentation technique essentielle pour : 1) Onboarding nouveaux développeurs, 2) Maintenance et évolution future, 3) Partage connaissance (pas de single point of failure), 4) Décisions d'architecture justifiées, 5) Compliance et audit, 6) Debugging facilité, 7) APIs utilisables par autres équipes, 8) Handover projets, 9) Formation utilisateurs. Types : README, API docs, architecture decisions (ADR), runbooks, troubleshooting guides. Outils : GitBook, Confluence, Docusaurus. Maintenir à jour crucial."
            },
            {
                "question": "Quelle est la différence entre un use case et une user story ?",
                "answer": "Use case : description détaillée d'une interaction utilisateur-système pour atteindre un objectif, format structuré avec acteurs, préconditions, scénarios principaux/alternatifs, postconditions. Focus technique et exhaustif. User story : description simple d'une fonctionnalité du point de vue utilisateur, format : 'En tant que [qui], je veux [quoi] afin de [pourquoi]'. Focus valeur métier et conversation. Use case = spécification détaillée, User story = besoin à développer. User stories sont décomposées en tâches techniques."
            }
        ],
        "tools": [
            {
                "question": "Quels sont les outils indispensables à ton environnement de développement ?",
                "answer": "Outils indispensables : 1) IDE/Éditeur : VS Code, IntelliJ, Eclipse avec extensions, 2) Versioning : Git + GitHub/GitLab, 3) Terminal/Shell : PowerShell, Bash, Zsh, 4) Navigateur avec dev tools, 5) Gestionnaire de paquets : npm, Maven, Composer, 6) Base de données : MySQL Workbench, pgAdmin, 7) API testing : Postman, Insomnia, 8) Docker pour conteneurisation, 9) Linter/Formatter pour la qualité code, 10) Debugger intégré, 11) Documentation : notes, wiki. Configuration synchronisée via dotfiles."
            },
            {
                "question": "Pourquoi utiliser un gestionnaire de versions comme Git ?",
                "answer": "Git apporte : 1) Historique complet des modifications avec possibilité de revenir en arrière, 2) Collaboration équipe sans conflits via branches et merge, 3) Sauvegarde distribuée (chaque clone = backup complet), 4) Branches pour développement parallèle de fonctionnalités, 5) Tags pour marquer les versions, 6) Audit trail pour traçabilité, 7) Integration CI/CD, 8) Workflows de développement (GitFlow, GitHub Flow), 9) Code reviews via pull requests, 10) Résolution intelligente des conflits. Indispensable pour tout projet sérieux."
            },
            {
                "question": "Comment assures-tu la compatibilité entre ton environnement local et l'environnement de production ?",
                "answer": "Compatibilité dev/prod : 1) Docker pour containerisation identique, 2) Variables d'environnement pour configuration, 3) Infrastructure as Code (Terraform, Ansible), 4) Même versions des dépendances (package-lock.json), 5) Tests dans environnements staging identiques à la prod, 6) CI/CD pipeline pour déploiements cohérents, 7) Configuration externalisée, 8) Monitoring et logs comparables, 9) Feature flags pour rollout progressif, 10) Documentation environnements. Principe : 'Dev/Prod Parity' des 12-factor apps."
            }
        ]
    },
   "DWWM": {
        "frontend": [
            {
                "question": "Quels outils as-tu utilisé ?",
                "answer": "Pour le développement frontend, j'utilise principalement : VS Code comme éditeur avec extensions ESLint/Prettier, Git pour le versioning, npm/yarn pour la gestion des paquets, Webpack/Vite pour le bundling, Chrome DevTools pour le debugging, Figma pour les maquettes, Postman pour tester les APIs, et des frameworks comme React/Vue.js selon le projet."
            },
            {
                "question": "Quelles sont les 3 étapes du maquettage ?",
                "answer": "Les 3 étapes du maquettage sont : 1) Wireframing : création de la structure et de l'organisation des éléments sans design visuel, focus sur l'UX et la hiérarchie de l'information. 2) Maquettage : ajout du design visuel (couleurs, typographies, images) pour créer l'apparence finale. 3) Prototypage : rendre la maquette interactive pour tester les parcours utilisateur et valider l'expérience avant le développement."
            },
            {
                "question": "Responsive design ?",
                "answer": "Le responsive design est une approche qui permet aux sites web de s'adapter automatiquement à différentes tailles d'écran (mobile, tablette, desktop). Techniques utilisées : media queries CSS, grilles flexibles (CSS Grid, Flexbox), images adaptatives (srcset), unités relatives (%, em, rem, vw, vh), approche mobile-first, et frameworks comme Bootstrap ou Tailwind CSS."
            },
            {
                "question": "UX ? UI ?",
                "answer": "UX (User Experience) concerne l'expérience globale de l'utilisateur : parcours, émotions, facilité d'usage, recherche utilisateur, tests d'utilisabilité. UI (User Interface) concerne l'interface visuelle : couleurs, typographies, boutons, disposition des éléments. UX = stratégie et recherche, UI = implémentation visuelle. Les deux sont complémentaires pour créer des produits utilisables et esthétiques."
            },
            {
                "question": "Connais-tu le système de composants ?",
                "answer": "Un système de composants (Design System) est une bibliothèque d'éléments UI réutilisables et cohérents : boutons, formulaires, cards, navigation, etc. Chaque composant a ses variantes, états et règles d'usage. Avantages : cohérence visuelle, développement accéléré, maintenance simplifiée, collaboration design/dev améliorée. Exemples : Material Design, Ant Design, ou systèmes custom avec Storybook."
            },
            {
                "question": "Qu'est-ce que le CSS ? Comment rendre responsive avec le CSS ?",
                "answer": "CSS (Cascading Style Sheets) est le langage de style qui définit l'apparence des éléments HTML : couleurs, polices, layouts, animations. Pour le responsive : 1) Media queries pour cibler différentes tailles d'écran, 2) Flexbox et CSS Grid pour des layouts adaptatifs, 3) Unités relatives (%, em, rem, vw, vh), 4) Images flexibles avec max-width: 100%, 5) Approche mobile-first avec min-width dans les media queries."
            },
            {
                "question": "Qu'est-ce que le SASS ? Différence avec le CSS ?",
                "answer": "SASS (Syntactically Awesome Style Sheets) est un préprocesseur CSS qui ajoute des fonctionnalités : variables ($primary-color), nesting (imbrication), mixins (fonctions réutilisables), fonctions, imports, conditions. SASS se compile en CSS standard. Avantages : code plus maintenable, DRY (Don't Repeat Yourself), organisation modulaire. Syntaxes : SCSS (.scss) proche du CSS, SASS (.sass) avec indentation."
            },
            {
                "question": "Tu as utilisé une librairie CSS (ex : tailwind) : peux-tu donner les avantages et les inconvénients ?",
                "answer": "Tailwind CSS - Avantages : développement rapide avec classes utilitaires, pas de CSS custom à écrire, design system cohérent, purge automatique du CSS inutilisé, responsive facile, customisation via config. Inconvénients : courbe d'apprentissage, HTML verbeux avec beaucoup de classes, dépendance à un framework, moins de flexibilité pour des designs très custom. Alternative : frameworks composants (Bootstrap) ou CSS-in-JS."
            },
            {
                "question": "Qu'est-ce que le Référencement naturel ? Que signifie S.E.O ? À quoi ça sert ? Pourquoi c'est important ? Quelles sont les bonnes pratiques (en citer au moins 3) ?",
                "answer": "SEO (Search Engine Optimization) = référencement naturel, techniques pour améliorer la visibilité d'un site dans les résultats de recherche Google. Importance : trafic gratuit, crédibilité, ROI élevé. Bonnes pratiques : 1) Contenu de qualité avec mots-clés pertinents, 2) Structure HTML sémantique (h1, h2, alt sur images), 3) Performance web (Core Web Vitals), 4) Mobile-friendly, 5) URLs optimisées, 6) Meta descriptions, 7) Maillage interne."
            },
            {
                "question": "Quelle architecture as-tu mis en place ?",
                "answer": "J'ai implémenté une architecture frontend modulaire avec : structure par composants (components, pages, services, utils), séparation des préoccupations (logique métier séparée de l'UI), gestion d'état centralisée (Redux/Vuex), routing côté client, APIs REST consommées via Axios, build optimisé avec Webpack/Vite, tests unitaires et E2E, déploiement CI/CD. Architecture évolutive et maintenable."
            },
            {
                "question": "Différence librairie VS framework ?",
                "answer": "Librairie : collection de fonctions que vous appelez dans votre code, vous gardez le contrôle du flux d'exécution (ex: jQuery, Lodash, Axios). Framework : structure qui définit l'architecture de l'application et appelle votre code, inversion de contrôle (ex: Angular, Vue.js, Express.js). Librairie = outil utilisé, Framework = fondation qui vous utilise. React est techniquement une librairie mais souvent perçu comme un framework avec son écosystème."
            },
            {
                "question": "Qu'est-ce que React ? Pourquoi avoir choisi React pour réaliser ton projet ?",
                "answer": "React est une librairie JavaScript pour créer des interfaces utilisateur avec une approche composants. Avantages : composants réutilisables, Virtual DOM pour performance, JSX expressif, écosystème riche, communauté active, backing Facebook/Meta. J'ai choisi React pour : sa flexibilité, sa popularité sur le marché, l'abondance de ressources, la facilité de maintenance, les performances, et l'expérience développeur excellente avec les React DevTools."
            },
            {
                "question": "Qu'est-ce qu'une SPA ? Avantages et inconvénients ?",
                "answer": "SPA (Single Page Application) : application web qui charge une seule page HTML et met à jour le contenu dynamiquement via JavaScript. Avantages : expérience utilisateur fluide, performance améliorée après chargement initial, facilite le développement mobile. Inconvénients : SEO plus complexe, temps de chargement initial plus long, gestion d'état complexe, accessibilité à surveiller, JavaScript obligatoire. Solutions : SSR (Next.js), SSG pour améliorer SEO et performance."
            },
            {
                "question": "A quoi sert vite ?",
                "answer": "Vite est un build tool moderne pour le développement frontend. Avantages : démarrage ultra-rapide grâce aux ES modules natifs, Hot Module Replacement (HMR) instantané, build de production optimisé avec Rollup, support TypeScript/JSX natif, plugins riches, configuration minimale. Remplace Webpack pour le développement avec des temps de build considérablement réduits. Parfait pour React, Vue, Vanilla JS."
            },
            {
                "question": "Qu'est-ce qu'un bundle JS ?",
                "answer": "Un bundle JS est un fichier JavaScript unique (ou plusieurs fichiers optimisés) qui contient tout le code de l'application : composants, librairies, assets. Le bundler (Webpack, Vite, Parcel) analyse les dépendances, optimise le code (minification, tree-shaking), gère les imports/exports, et produit des fichiers prêts pour la production. Optimisations : code splitting, lazy loading, compression, cache busting."
            },
            {
                "question": "Comment, depuis un composant JSX, on en arrive à un fichier JS dans le navigateur ?",
                "answer": "Processus de transformation : 1) Code JSX écrit par le développeur, 2) Babel transpile JSX en appels React.createElement(), 3) Bundler (Webpack/Vite) résout les imports et crée le bundle, 4) Optimisations : minification, tree-shaking, code splitting, 5) Fichiers générés dans dist/build, 6) Serveur web sert les fichiers statiques, 7) Navigateur télécharge et exécute le JavaScript. En développement : HMR pour mise à jour instantanée."
            },
            {
                "question": "Comment React gère-t-il la mise à jour du DOM ?",
                "answer": "React utilise le Virtual DOM : 1) Représentation JS en mémoire du DOM réel, 2) À chaque changement d'état, création d'un nouveau Virtual DOM, 3) Algorithme de diffing compare ancien vs nouveau Virtual DOM, 4) Calcul des changements minimaux nécessaires, 5) Réconciliation : mise à jour sélective du DOM réel. Optimisations : keys pour les listes, React.memo pour éviter re-renders inutiles, useMemo/useCallback pour optimisation."
            },
            {
                "question": "Qu'est-ce que le DOM ?",
                "answer": "DOM (Document Object Model) : représentation arborescente des éléments HTML d'une page web. Chaque balise HTML devient un nœud que JavaScript peut manipuler dynamiquement. Structure hiérarchique avec parent/enfant, propriétés et méthodes pour modification (getElementById, createElement, appendChild). Interface entre HTML/CSS et JavaScript. Essential pour l'interactivité web moderne."
            },
            {
                "question": "Qu'est-ce que npm ? A quoi sert le package.json ? Le dossier node_modules ?",
                "answer": "npm (Node Package Manager) : gestionnaire de paquets JavaScript pour installer/gérer les dépendances. package.json : fichier de configuration contenant métadonnées du projet, dépendances (dependencies/devDependencies), scripts NPM, version. node_modules : dossier contenant toutes les dépendances installées et leurs sous-dépendances. Ignore node_modules dans Git, utilise package-lock.json pour versions exactes, npm install pour restaurer."
            },
            {
                "question": "Qu'est-ce qu'un linter ? A quoi ça sert ?",
                "answer": "Un linter est un outil d'analyse statique qui détecte erreurs, bugs potentiels et violations de style dans le code. Objectifs : qualité code constante, détection précoce d'erreurs, respect des conventions équipe, amélioration lisibilité. Exemples : ESLint (JavaScript), Prettier (formatage), TSLint (TypeScript). Configuration via fichiers (.eslintrc), intégration IDE, hooks Git, CI/CD. Combiné avec formatters automatiques."
            },
            {
                "question": "Qu'est-ce que le JSX ? Différence avec le JS ?",
                "answer": "JSX (JavaScript XML) : extension syntaxique de JavaScript qui permet d'écrire des éléments HTML dans le code JavaScript. Ressemble à HTML mais avec la puissance de JS. Différences avec JS : 1) Syntaxe déclarative vs impérative, 2) Expressions JS entre accolades {}, 3) Attributs en camelCase, 4) className au lieu de class. JSX se transpile en appels React.createElement(). Plus lisible et expressif que la manipulation DOM traditionnelle."
            },
            {
                "question": "Comment met-on le routing en place dans React ? Qu'est-ce qu'un loader ?",
                "answer": "Routing React avec React Router : 1) Installation react-router-dom, 2) BrowserRouter wrap l'application, 3) Routes définit les chemins, 4) Route pour chaque page, 5) Link pour navigation. Nouveau : createBrowserRouter avec data loading. Loader : fonction qui charge les données avant le rendu du composant, évite les états de chargement. Exemple : const loader = () => fetch('/api/users'). Améliore UX et performance."
            },
            {
                "question": "Qu'est-ce qu'un composant ? À quoi ça sert ?",
                "answer": "Un composant est une unité d'interface utilisateur réutilisable et autonome qui encapsule logique et rendu. Avantages : 1) Réutilisabilité dans différentes parties de l'app, 2) Maintenabilité par isolation des responsabilités, 3) Testabilité indépendante, 4) Composition pour UIs complexes, 5) Séparation des préoccupations. Types : fonctionnels (hooks) ou classe, contrôlés/non-contrôlés. Base de l'architecture moderne frontend."
            },
            {
                "question": "A quoi sert le .map en JS ? Pourquoi l'utilise-t-on régulièrement en JSX ?",
                "answer": "Array.map() transforme chaque élément d'un tableau et retourne un nouveau tableau. En JSX, utilisé pour rendre des listes dynamiques : users.map(user => <UserCard key={user.id} user={user} />). Chaque élément du tableau devient un composant JSX. Important : ajouter une prop 'key' unique pour optimiser le re-rendering React. Alternative : for loops mais map est plus fonctionnel et expressif."
            },
            {
                "question": "Lorsque tu déclares une variable, à quoi dois-tu faire attention ?",
                "answer": "Déclaration variables JS : 1) Utiliser const par défaut, let si réassignation nécessaire, éviter var, 2) Noms explicites et significatifs (camelCase), 3) Scope approprié (éviter variables globales), 4) Initialisation si possible, 5) Éviter hoisting involontaire, 6) Types cohérents (TypeScript recommandé), 7) Conventions d'équipe respectées, 8) Éviter mots-clés réservés. Bon naming améliore lisibilité et maintenance."
            },
            {
                "question": "Quels types de données connais-tu en JS ?",
                "answer": "Types primitifs JS : 1) Number (entiers, décimaux, NaN, Infinity), 2) String (texte, template literals), 3) Boolean (true/false), 4) Undefined (variable non assignée), 5) Null (valeur vide intentionnelle), 6) Symbol (identifiant unique), 7) BigInt (grands entiers). Types complexes : Object (objets, tableaux, fonctions, dates). JavaScript est dynamiquement typé, typeof pour vérifier types."
            },
            {
                "question": "Qu'est-ce qu'un objet ?",
                "answer": "Un objet JS est une collection de propriétés (clé-valeur) qui représente une entité. Création : littéral {}, constructeur Object(), classe. Propriétés accessibles par notation point (obj.prop) ou crochets (obj['prop']). Peut contenir : données primitives, autres objets, fonctions (méthodes). Référence par défaut, non par valeur. Base de la programmation orientée objet en JavaScript."
            },
            {
                "question": "Qu'est-ce qu'une boucle ?",
                "answer": "Une boucle est une structure de contrôle qui répète un bloc de code tant qu'une condition est vraie. Types JS : 1) for (compteur classique), 2) for...in (propriétés objet), 3) for...of (éléments itérables), 4) while (condition en début), 5) do...while (condition en fin). Utilisées pour : traitement de tableaux, répétition d'opérations, parcours de données. Attention aux boucles infinies."
            },
            {
                "question": "Qu'est-ce qu'une clé ? Une valeur ?",
                "answer": "Dans un objet JS : Clé (key/propriété) = identifiant qui nomme une propriété de l'objet, peut être string ou Symbol. Valeur (value) = donnée associée à la clé, peut être de tout type. Exemple : {nom: 'Jean', age: 30} - 'nom' et 'age' sont des clés, 'Jean' et 30 sont des valeurs. Accès : obj.clé ou obj['clé']. Méthodes : Object.keys(), Object.values(), Object.entries()."
            },
            {
                "question": "Qu'est-ce qu'une fonction ? Un paramètre ? Un argument ? Le return ?",
                "answer": "Fonction : bloc de code réutilisable qui effectue une tâche spécifique. Paramètre : variable dans la déclaration de fonction (function add(a, b)). Argument : valeur réelle passée lors de l'appel (add(5, 3)). Return : instruction qui renvoie une valeur et termine l'exécution de la fonction. Sans return, fonction retourne undefined. Types : déclaration, expression, arrow function, fonction anonyme."
            },
            {
                "question": "Qu'est-ce que la POO ? Une class ? Un constructor ? Une propriété ? Une méthode ? Le mot clé 'this' ? Une instance ?",
                "answer": "POO (Programmation Orientée Objet) : paradigme basé sur objets contenant données et méthodes. Classe : modèle/blueprint pour créer des objets. Constructor : méthode spéciale d'initialisation d'une instance. Propriété : variable d'instance stockant des données. Méthode : fonction d'une classe. 'this' : référence à l'instance courante. Instance : objet créé à partir d'une classe via 'new'. Encapsulation, héritage, polymorphisme."
            },
            {
                "question": "Qu'est-ce que l'héritage ? Le mot clé 'extends' ? Quels sont ses inconvénients ?",
                "answer": "Héritage : mécanisme permettant à une classe d'hériter propriétés et méthodes d'une classe parent. 'extends' : mot-clé créant une relation d'héritage (class Child extends Parent). Inconvénients : 1) Couplage fort parent-enfant, 2) Hiérarchies complexes difficiles à maintenir, 3) Problème du diamant, 4) Moins flexible que composition. Alternative : composition over inheritance, mixins, interfaces."
            },
            {
                "question": "Qu'est-ce qu'une interface ? À quoi ça sert ?",
                "answer": "Interface (TypeScript) : contrat définissant la structure qu'un objet doit respecter, sans implémentation. Définit types des propriétés et signatures des méthodes. Sert à : 1) Type checking à la compilation, 2) Documentation du code, 3) Contrats entre composants, 4) Polymorphisme, 5) IntelliSense amélioré. JavaScript pur n'a pas d'interfaces, mais TypeScript les simule pour la robustesse."
            },
            {
                "question": "Qu'est-ce qu'une méthode abstraite ?",
                "answer": "Méthode abstraite : méthode déclarée sans implémentation dans une classe parente, doit être implémentée par les classes enfants. Force un contrat d'implémentation. JavaScript/TypeScript : simulation via erreurs dans méthodes ou classes abstraites TypeScript. Utilité : définir une interface commune tout en laissant l'implémentation spécifique aux sous-classes. Partie du pattern Template Method."
            },
            {
                "question": "Qu'est-ce qu'une classe abstraite ?",
                "answer": "Classe abstraite : classe qui ne peut pas être instanciée directement, sert de base pour d'autres classes. Contient méthodes abstraites (à implémenter) et/ou concrètes (déjà implémentées). TypeScript supporte avec 'abstract class'. JavaScript : simulation par convention ou erreurs dans constructeur. Utilité : partager code commun tout en forçant implémentation de méthodes spécifiques."
            },
            {
                "question": "Qu'est-ce qu'une props ? Pourquoi les utiliser ? Quel grand principe cela permet-il de respecter ? Montre-moi en une dans ton code en m'expliquant le plus rigoureusement possible",
                "answer": "Props (properties) : données passées d'un composant parent à un composant enfant en React. Lecture seule, permettent la communication descendante. Principe respecté : immutabilité et flux de données unidirectionnel. Exemple : <UserCard name='Jean' age={30} /> - le composant UserCard reçoit props.name et props.age. Avantages : composants réutilisables, testables, prédictibles. Destructuration possible : function UserCard({name, age}) { return <div>{name}, {age} ans</div>; }"
            },
            {
                "question": "A quoi sert le mot clé 'default' dans 'export default myFunction' ?",
                "answer": "export default définit l'export principal d'un module ES6. Un seul export default par fichier. Import sans accolades : import MyFunction from './module'. Différence avec export nommé : export {myFunction} nécessite import {myFunction}. Export default plus pratique pour modules avec une seule fonction/classe principale. Combinable avec exports nommés dans le même fichier."
            },
            {
                "question": "En React, où placerais-tu des objets 'globaux et utilisables par tous les composants' ?",
                "answer": "Gestion d'état global React : 1) Context API + useContext pour états simples, 2) Redux/Redux Toolkit pour applications complexes, 3) Zustand pour solution légère, 4) Custom hooks pour logique partagée, 5) Variables d'environnement (process.env), 6) Singleton pattern pour services. Context évite prop drilling, Redux pour état complexe avec time-travel debugging. Choisir selon complexité de l'application."
            },
            {
                "question": "À quoi sert useEffect ? (il faut savoir expliquer tous les 'use' : useEffect, useMemo, useNavigate, etc…)",
                "answer": "useEffect : gère les effets de bord (API calls, DOM manipulation, subscriptions). useEffect(() => {}, [deps]). useMemo : mémorise résultat de calcul coûteux. useCallback : mémorise fonction pour éviter re-créations. useState : état local du composant. useContext : consomme Context. useReducer : état complexe avec actions. useRef : référence DOM ou valeur mutable. useNavigate : navigation programmatique (React Router). Custom hooks : logique réutilisable."
            },
            {
                "question": "Dans un useEffect, à quoi sert le tableau de dépendances ? S'il est vide, que se passe-t-il ? Et si j'oublie le tableau de dépendances ?",
                "answer": "Tableau de dépendances contrôle quand useEffect s'exécute : 1) [dep1, dep2] : re-exécute si dep1 ou dep2 change, 2) [] : exécute une seule fois au montage (componentDidMount), 3) Pas de tableau : exécute à chaque render (dangereux, peut causer boucles infinies). Cleanup function : return () => {} pour nettoyer (subscriptions, timers). Toujours spécifier les dépendances utilisées dans l'effet."
            },
            {
                "question": "Montre-moi comment tu trouves une réponse sur internet ?",
                "answer": "Méthodologie de recherche : 1) Définir précisément le problème, 2) Mots-clés spécifiques + technologies (React error, JavaScript array methods), 3) Sources fiables : MDN, documentation officielle, Stack Overflow, 4) GitHub Issues pour bugs spécifiques, 5) Blogs techniques reconnus, 6) Forums spécialisés, 7) Valider plusieurs sources, 8) Tester la solution localement, 9) Comprendre le pourquoi, pas seulement le comment."
            },
            {
                "question": "À quoi sert de commenter son code ? C'est bien ou c'est mal ? Qu'est-ce qu'un bon commentaire ? Un mauvais ?",
                "answer": "Commentaires : Bon si expliquent le POURQUOI, pas le QUOI. Bon commentaire : justifie décisions complexes, explique business logic, documente APIs, warnings importants. Mauvais : répète le code évident, obsolète, mensonger. Clean Code : code auto-documenté via noms explicites > commentaires. JSDoc pour fonctions publiques. Maintenir cohérence commentaires/code. Éviter sur-commenter du code simple."
            },
            {
                "question": "Comment travailles-tu en groupe ? Quels outils utilises-tu ?",
                "answer": "Travail en équipe : 1) Git flow avec branches feature, pull requests, code reviews, 2) Outils : Slack/Teams communication, Jira/Trello gestion tâches, Figma designs, 3) Conventions code partagées (ESLint, Prettier), 4) Daily meetings, sprint planning, retrospectives, 5) Documentation partagée (Confluence, Notion), 6) CI/CD pour intégration continue, 7) Pair programming ponctuel, 8) Tests automatisés pour confiance déploiements."
            },
            {
                "question": "Qu'est-ce que git ? github ? Quelles sont les bonnes pratiques à respecter que tu connais ?",
                "answer": "Git : système de contrôle de version distribué pour tracker changements code. GitHub : plateforme cloud hébergeant repos Git avec features collaboration. Bonnes pratiques : 1) Commits atomiques avec messages explicites, 2) Branches feature pour nouvelles fonctionnalités, 3) Pull requests avec reviews, 4) .gitignore pour fichiers temporaires, 5) Ne jamais commiter secrets/passwords, 6) Rebase pour historique propre, 7) Tags pour versions, 8) Conventional commits."
            }
        ],
        "backend": [
            {
                "question": "Qu'est-ce que le SQL ? Le NoSQL ? Un SGBDR ? Quel SGBDR utilises-tu dans ton projet ? Connais-tu une alternative ?",
                "answer": "SQL (Structured Query Language) : langage de requête pour bases de données relationnelles avec schéma fixe, tables liées, ACID compliance. NoSQL : bases non-relationnelles avec schéma flexible (document, clé-valeur, graphe, colonne). SGBDR (Système de Gestion de Base de Données Relationnelles) : MySQL, PostgreSQL, SQL Server. J'utilise MySQL pour sa simplicité et PostgreSQL pour ses fonctionnalités avancées. Alternatives : MongoDB (NoSQL document), Redis (clé-valeur)."
            },
            {
                "question": "Écris moi une jointure au tableau (il faut alors le faire sur tableau blanc. Il faut bien connaître tous les fondamentaux en SQL)",
                "answer": "Jointure SQL exemple : SELECT u.nom, c.titre FROM users u INNER JOIN commandes c ON u.id = c.user_id WHERE u.actif = 1; Types : INNER JOIN (correspondance exacte), LEFT JOIN (tous les enregistrements de gauche), RIGHT JOIN (tous de droite), FULL OUTER JOIN (tous). Jointure externe : LEFT JOIN avec WHERE IS NULL pour trouver orphelins. Performance : index sur colonnes de jointure, éviter jointures sur trop de tables."
            },
            {
                "question": "Qu'est-ce qu'une clé primaire ? Clé étrangère ? Table de jointure ?",
                "answer": "Clé primaire : identifiant unique de chaque ligne, non NULL, une seule par table, assure intégrité d'entité. Clé étrangère : référence à clé primaire d'autre table, maintient intégrité référentielle, peut être NULL. Table de jointure : table intermédiaire pour relations N-N, contient clés étrangères des deux tables reliées + données spécifiques à la relation. Contraintes : CASCADE, SET NULL, RESTRICT pour actions sur suppressions/modifications."
            },
            {
                "question": "Parle-moi des cardinalités ?",
                "answer": "Cardinalités définissent relations entre entités : 1-1 (un-à-un) : chaque occurrence liée à une seule (Personne-Passeport), 1-N (un-à-plusieurs) : une occurrence liée à plusieurs (Client-Commandes), N-N (plusieurs-à-plusieurs) : plusieurs liées à plusieurs (Étudiants-Cours, nécessite table de jointure). Implémentation : 1-1 et 1-N avec clé étrangère, N-N avec table d'association. Cardinalités min/max précisent participation obligatoire/optionnelle."
            },
            {
                "question": "Quelles contraintes connais-tu ? (Appliquées sur des colonnes)",
                "answer": "Contraintes SQL sur colonnes : 1) NOT NULL : valeur obligatoire, 2) UNIQUE : valeurs uniques dans la colonne, 3) PRIMARY KEY : NOT NULL + UNIQUE, 4) FOREIGN KEY : référence autre table, 5) CHECK : condition personnalisée (âge > 0), 6) DEFAULT : valeur par défaut, 7) AUTO_INCREMENT : incrémentation automatique. Contraintes garantissent intégrité des données au niveau base, complètent validation applicative."
            },
            {
                "question": "De quoi est constituée une table SQL ?",
                "answer": "Table SQL constituée de : 1) Colonnes (attributs) avec type de données (VARCHAR, INT, DATE, etc.), 2) Lignes (enregistrements/tuples) contenant les données, 3) Clé primaire identifiant unique, 4) Contraintes d'intégrité, 5) Index pour performance, 6) Triggers éventuels, 7) Métadonnées (nom table, schéma, permissions). Structure définie par DDL (Data Definition Language : CREATE, ALTER, DROP)."
            },
            {
                "question": "Quelles failles de sécurité connais-tu ? Qu'est-ce qu'une injection SQL ? Une attaque CSRF ? Une attaque XSS ?",
                "answer": "Failles sécurité web : 1) Injection SQL : insertion code SQL malveillant via inputs utilisateur, contournement authentification/accès données. Prévention : requêtes préparées. 2) CSRF : exécution actions non autorisées au nom utilisateur connecté. Prévention : tokens CSRF. 3) XSS : injection scripts malveillants dans pages web. Prévention : échappement données, CSP headers. Autres : authentification cassée, exposition données, composants vulnérables."
            },
            {
                "question": "Qu'est-ce que le format JSON ? Qu'est-ce que la sérialisation ?",
                "answer": "JSON (JavaScript Object Notation) : format d'échange de données léger, lisible, basé sur syntaxe JS mais indépendant du langage. Structure : objets {}, tableaux [], chaînes, nombres, booléens, null. Sérialisation : processus de conversion d'un objet en format transmissible/stockable (JSON, XML, binaire). Désérialisation : processus inverse. Utilisé pour APIs REST, configuration, stockage données structurées."
            },
            {
                "question": "Comment sont transférées les données entre ton frontend et ton backend ?",
                "answer": "Transfert données Frontend/Backend : 1) Protocole HTTP/HTTPS, 2) Format JSON pour APIs REST, 3) Méthodes HTTP : GET (lecture), POST (création), PUT (modification complète), PATCH (modification partielle), DELETE (suppression), 4) Headers pour métadonnées (Content-Type, Authorization), 5) Status codes (200 OK, 400 Bad Request, 500 Server Error), 6) CORS pour cross-origin, 7) Authentication via JWT/cookies."
            },
            {
                "question": "Quelles sont les 2 parties qui constituent ton backend ?",
                "answer": "Backend constitué de : 1) API/Serveur d'application : gère requêtes HTTP, logique métier, authentification, validation, routing (Express.js, Spring Boot, Laravel), 2) Base de données : stockage persistant des données avec SGBDR (MySQL, PostgreSQL) ou NoSQL (MongoDB). Communication via ORM/ODM ou requêtes SQL directes. Séparation permet scalabilité indépendante et maintenance facilitée."
            },
            {
                "question": "Qu'est-ce qu'une API ? Une WEB API ?",
                "answer": "API (Application Programming Interface) : interface permettant communication entre applications, définit méthodes d'accès aux fonctionnalités. Web API : API accessible via protocoles web (HTTP/HTTPS), généralement REST ou GraphQL. Expose endpoints URL pour CRUD operations. Avantages : séparation frontend/backend, réutilisabilité, intégrations tierces, développement parallèle équipes. Documentation OpenAPI/Swagger recommandée."
            },
            {
                "question": "Qu'est-ce qu'une base de données ?",
                "answer": "Base de données : système organisé de stockage, gestion et récupération de données structurées. Types : relationnelles (tables liées, SQL), NoSQL (document, clé-valeur, graphe, colonne). Fonctionnalités : CRUD operations, transactions, index, backup, sécurité, concurrent access. SGBD gère : intégrité données, performance, sécurité, concurrence. Essentielle pour persistence applicative."
            },
            {
                "question": "Quelle architecture as-tu utilisé pour organiser ta WEB API ?",
                "answer": "Architecture Web API : 1) MVC (Model-View-Controller) avec séparation couches, 2) Architecture en couches : routes → controllers → services → repositories → database, 3) Pattern Repository pour abstraction données, 4) Middleware pour concerns transversaux (auth, logging, CORS), 5) Services pour logique métier, 6) DTOs pour validation/transformation données, 7) Error handling centralisé, 8) Configuration externalisée. Structure maintenue et testable."
            },
            {
                "question": "Qu'est-ce que la spécification REST ? RESTful ?",
                "answer": "REST (Representational State Transfer) : style architectural pour services web basé sur HTTP. Principes : 1) Stateless (sans état), 2) Interface uniforme (HTTP verbs), 3) Cacheable, 4) Client-serveur séparé, 5) Architecture en couches, 6) Code on demand (optionnel). RESTful : API qui respecte les principes REST. Utilise : URLs comme ressources, méthodes HTTP appropriées, status codes, JSON/XML, HATEOAS pour discoverability."
            },
            {
                "question": "Ta WEB API est-elle REST ou RESTful ? Quels principes respecte-t-elle ?",
                "answer": "Mon API est RESTful car respecte : 1) URLs représentent ressources (/users, /users/123), 2) Méthodes HTTP appropriées (GET lecture, POST création), 3) Stateless (pas de session serveur), 4) Status codes standards (200, 201, 400, 404, 500), 5) Format JSON uniforme, 6) Cacheable avec headers appropriés, 7) CORS pour séparation client/serveur. Peut améliorer : HATEOAS pour navigation API, versioning explicite."
            },
            {
                "question": "Que signifie dans ton controller le 'res.json()' ?",
                "answer": "res.json() (Express.js) : méthode qui sérialise un objet JavaScript en JSON et l'envoie comme réponse HTTP. Définit automatiquement Content-Type: application/json, convertit données avec JSON.stringify(), termine la requête. Exemple : res.json({message: 'Success', data: users}) envoie objet JSON au client. Alternative : res.send() plus générique, res.status(200).json() avec code statut."
            },
            {
                "question": "Parle-moi des différents types de requêtes",
                "answer": "Méthodes HTTP : 1) GET : récupération données, idempotent, cacheable, paramètres URL, 2) POST : création ressource, non-idempotent, body required, 3) PUT : modification complète, idempotent, remplace ressource, 4) PATCH : modification partielle, update fields spécifiques, 5) DELETE : suppression, idempotent, 6) HEAD : headers seulement (pas de body), 7) OPTIONS : méthodes supportées (CORS preflight). Idempotence importante pour retry logic."
            },
            {
                "question": "Montre-moi dans ton backend le chemin qu'emprunte une requête de type GET sur la route 'X'",
                "answer": "Chemin requête GET /api/users : 1) Serveur reçoit requête HTTP, 2) Router Express identifie route correspondante, 3) Middleware d'authentification vérifie token JWT, 4) Controller getUsersController appelé, 5) Controller appelle service UserService.getAllUsers(), 6) Service appelle repository UserRepository.findAll(), 7) Repository exécute requête SQL, 8) Données remontent : DB → Repository → Service → Controller, 9) Controller utilise res.json() pour réponse, 10) Client reçoit JSON."
            },
            {
                "question": "Idem pour POST. Que doit ajouter le client, par rapport à une requête GET ?",
                "answer": "Requête POST /api/users : parcours similaire mais 1) Client ajoute : body JSON avec données utilisateur, header Content-Type: application/json, méthode POST, 2) Middleware validation vérifie format/contraintes données, 3) Controller extrait données req.body, 4) Service valide business rules, 5) Repository INSERT en base, 6) Réponse 201 Created avec nouvel utilisateur. Différences GET : body data, validation input, création ressource, status 201."
            },
            {
                "question": "À quoi sert le index.js ? Le table.js ? Le seed.js ?",
                "answer": "Fichiers Node.js/Backend : 1) index.js : point d'entrée application, configure serveur Express, middleware, routes, démarre serveur sur port spécifié, 2) table.js : création/migration schéma base de données, définit structure tables, colonnes, contraintes, 3) seed.js : peuplement base avec données initiales/test, fixtures pour développement, users admin par défaut. Scripts npm pour exécution : npm start, npm run migrate, npm run seed."
            },
            {
                "question": "Dans tes managers : pourquoi as-tu utilisé extends sur un AbstractManager ?",
                "answer": "Pattern héritage avec AbstractManager : 1) Factorisation code commun (connection DB, méthodes CRUD basiques), 2) Respect DRY principle, 3) Cohérence interface entre managers, 4) Maintenance centralisée des fonctionnalités communes, 5) Extension avec méthodes spécifiques par entité. AbstractManager contient : findAll(), findById(), create(), update(), delete(). Managers spécifiques étendent avec findByEmail(), findByCategory(), etc."
            },
            {
                "question": "Qu'est-ce qu'une middleware ? Peux-tu m'en montrer/décrire un ? Quels sont les 3 paramètres que prend un midleware ? À quoi sert le troisième justement ?",
                "answer": "Middleware Express : fonction exécutée entre requête et réponse, prend 3 paramètres : (req, res, next). 1) req : objet requête HTTP, 2) res : objet réponse HTTP, 3) next : fonction pour passer au middleware suivant. Exemple authentification : const authMiddleware = (req, res, next) => { if (!req.headers.authorization) return res.status(401).json({error: 'Token required'}); next(); }. Sans next(), requête bloquée. Ordre important dans app.use()."
            },
            {
                "question": "Comment utilises-tu un midleware ?",
                "answer": "Utilisation middleware Express : 1) Global : app.use(middleware) pour toutes routes, 2) Spécifique : app.get('/protected', authMiddleware, controller) pour routes ciblées, 3) Router : router.use(middleware) pour groupe routes, 4) Conditionnel : if/else dans middleware. Ordre crucial : logging → CORS → auth → validation → routes → error handling. Built-in : express.json(), express.static(). Custom pour besoins spécifiques."
            },
            {
                "question": "Comment as-tu mis en place l'authentification ?",
                "answer": "Authentification implémentée avec : 1) JWT (JSON Web Tokens) pour stateless auth, 2) Route POST /auth/login vérifie credentials, 3) Hash passwords avec bcrypt, 4) Génération token JWT avec payload user + expiration, 5) Middleware vérifie token sur routes protégées, 6) Headers Authorization: Bearer <token>, 7) Refresh tokens pour sécurité, 8) Logout côté client (suppression token). Alternative : sessions + cookies pour apps traditionnelles."
            },
            {
                "question": "Peux-tu me parler du JWT ? Des cookies ? Me montrer où tu les as impleménté ?",
                "answer": "JWT : token auto-contenu avec header.payload.signature, payload contient user info + expiration, signature vérifie intégrité. Avantages : stateless, scalable, cross-domain. Cookies : stockage côté client géré par navigateur, httpOnly pour sécurité, SameSite pour CSRF. Implémentation : jwt.sign() pour création, jwt.verify() pour validation, middleware authentification extrait token header Authorization, decode payload pour user context. Choix selon besoins : JWT pour APIs, cookies pour web apps."
            },
            {
                "question": "Pourquoi est-il important de vérifier, côté backend, les données que tu reçois depuis ton frontend ? As-tu mis en place cette couche de vérification ?",
                "answer": "Validation backend critique car : 1) Sécurité (frontend contournable), 2) Intégrité données business, 3) Protection injection attacks, 4) Conformité contraintes DB, 5) Never trust client data. Implémentation : middleware validation avec Joi/Yup, schémas de validation par route, sanitization inputs, error handling avec messages appropriés. Validation : types, formats, longueurs, business rules. Double validation frontend (UX) + backend (sécurité) recommended."
            }
        ],
        "fullstack": [
            {
                "question": "En cliquant sur ton bouton 'X' de ton application, peux-tu me décrire les couches que traverse ta requête, du client vers le serveur puis du serveur vers le client ? Peux-tu me montrer le code aussi, qui est exécuté ligne par ligne ?",
                "answer": "Parcours complet requête : CLIENT : 1) onClick handler déclenché, 2) fetch('/api/users', {method: 'DELETE', headers: {Authorization: Bearer token}}) envoyé, SERVEUR : 3) Express router identifie route DELETE /api/users/:id, 4) Middleware auth vérifie token JWT, 5) Controller deleteUser extrait ID params, 6) Service validateDelete vérifie business rules, 7) Repository exécute DELETE FROM users WHERE id = ?, 8) Réponse 204 No Content, CLIENT : 9) .then() traite réponse, 10) État React mis à jour, 11) Re-render composant sans utilisateur supprimé."
            },
            {
                "question": "Tu affiches X éléments sur cette page. Tu as fait un 'getAll()'. Mais si tu avais 1 million d'objets à récupérer, quel serait le problème ? Que pourrais-tu mettre en place ?",
                "answer": "Problèmes 1M objets : 1) Mémoire serveur insuffisante, 2) Temps réponse très long, 3) Bande passante saturée, 4) Interface utilisateur inutilisable. Solutions : 1) Pagination : LIMIT/OFFSET SQL, query params ?page=1&limit=20, 2) Lazy loading : chargement à la demande, 3) Virtual scrolling : rendu éléments visibles uniquement, 4) Filtres/recherche pour réduire dataset, 5) Cache côté serveur, 6) Index DB optimisés, 7) Cursors pour pagination performante grandes tables."
            }
        ],
        "modern_practices": [
            {
                "question": "As-tu écris des tests ? À quoi ça sert ?",
                "answer": "Tests implémentés : 1) Tests unitaires (Jest) pour fonctions pures et composants isolés, 2) Tests intégration (Supertest) pour APIs, 3) Tests E2E (Cypress) pour parcours utilisateur. Utilité : 1) Détection précoce bugs, 2) Confiance dans refactoring, 3) Documentation comportement attendu, 4) Régression prevention, 5) Meilleure architecture code (testabilité force découplage), 6) CI/CD avec gates qualité. Pyramide tests : nombreux unitaires, quelques intégration, peu E2E."
            },
            {
                "question": "Comment fonctionne la mise en prod ? Qu'est-ce que la CI/CD ? Quels outils connais-tu ?",
                "answer": "Mise en prod avec CI/CD : 1) Développeur push code sur Git, 2) CI déclenche : build, tests, analyse qualité, 3) Si succès, CD déploie automatiquement, 4) Monitoring post-déploiement. CI/CD : Continuous Integration (merge fréquent + tests) + Continuous Deployment (déploiement automatique). Outils : GitHub Actions, GitLab CI, Jenkins, Azure DevOps. Pipeline : source → build → test → deploy → monitor. Avantages : déploiements fréquents, erreurs détectées tôt, rollback rapide."
            },
            {
                "question": "Qu'est-ce qu'un VPS ? Une solution Cloud ?",
                "answer": "VPS (Virtual Private Server) : serveur virtuel dédié sur hardware partagé, isolation ressources, accès root, configuration libre. vs Mutualisé (ressources partagées) vs Dédié (hardware exclusif). Cloud : infrastructure élastique pay-as-you-use, scaling automatique, haute disponibilité. Types : IaaS (infra), PaaS (plateforme), SaaS (logiciel). Providers : AWS, Azure, GCP, OVH. Avantages cloud : pas d'investissement hardware, maintenance gérée, scaling global."
            }
        ]
    }
}
